<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78C-CCK-MCD {C-UDP; EBM-APPLE} (Macintosh; U; PPC) [Netscape]">
   <title>CallingCFromClean.doc</title>
</head>
<body>
<font size=+2>Calling C functions from Clean</font>
<p><font size=+1>1. INTRODUCTION</font>
<p>This document describes how functions written in the programming language
C can be called from Clean using a tool called htoclean. htoclean translates
a specification containing both C and Clean definitions of function types,
types and constants into Clean functions which directly call the corresponding
C function. This specification is stored in a .h file, which can be #included
in a C program just like a normal C header file. An example of such a specification
is:
<p>int add (int v1,int v2);
<p>This is the prototype of a C function 'add' that has two arguments of
type int and a result of type int. The file example_int2.h in the Examples
folder that is included with this document (or see the appendix ) contains
this function prototype. To be able to call this function from Clean, we
use htoclean.
<p>1.1 USING HTOCLEAN
<p>On windows and unix, htoclean is a command line tool and is invoked
by cd-ing to the Examples directory and typing (with htoclean in your PATH):
<br>htoclean example_int2.h
<br>or (without .h)
<br>htoclean example_int2
<br>On the PowerMacintosh, the file selecter is used to indicate the .h
file that is to be translated.
<p>htoclean reads this .h file and generates the files: example_int2.dcl
and example_int2.icl. The generated module contains the definition of the
Clean function:
<p>add :: !Int !Int -> Int
<p>that calls the add function written in C.
<br>The file example_int1_c.c contains a definition of add that adds these
numbers. A C compiler is used to compile this .c file, and the object file
generated by the c compiler is linked with the code generated by Clean
to create an executable file. How to do this is explained in chapter 3.
<p><font size=+1>2. HTOCLEAN FEATURES</font>
<p>2.1 COMMENTS
<p>The .h definition file may contains comments. Both '/* comment */' and
'// comment' are allowed. '//' comments are not allowed in ansi C, but
some compilers support it. '/* */' comments should not be nested.
<p>2.2 INTEGERS
<p>C function types using int arguments and results may be specified in
the .h definition file. For an example,.see example_int1.h in the Examples
folder.
<p>2.3 POINTERS
<p>Pointers to int, double, void or structs, and pointers to pointers,
may be passed to and returned by C functions. In Clean these pointers all
have type Int. This is possible because all current implementations of
Clean use 32 bit pointers and integers. For example (see example_int2)
:
<p>int *store_int (int *p,int offset,int value); /* p [offset] = value
*/
<p>In Clean this function has type:
<p>store_int :: !Int !Int !Int -> Int
<p>2.4 CLEAN TYPES IN THE .H SPECIFICATION FILE
<p>The type of a function in Clean may be added to the .h file, by writing:
<p>Clean ( clean_function_type )
<p>for example:
<p>Clean (store_int :: Int Int Int -> Int)
<p>To hide these types from the C compiler we use the C preprocessor. We
define
<br>#define Clean(a)
<br>in the file Clean.h and include Clean.h.
<p>Annotations (like ! and *) are not allowed in these function types.
Since unevaluated objects cannot be passed to or returned by C functions,
htoclean automatically adds strictness annotations (!) to all arguments
and data structures, so there is no need to specify !'s in types. * is
currently not allowed, but objects can be made unique using type synonyms.
<p>2.5 TYPE SYNONYMS
<p>Type synonyms can be defined with:
<p>Clean ( :: TypeSynonym :== type )
<p>The type may be an Int,tuple or type synonym. The type synonym can be
made unique by prefixing the name with a '*'. Several function types and
type synonyms can be written with one Clean( .. ) definition by separating
the definitions by a ';'. For example:
<p>Clean (
<br>&nbsp;&nbsp;&nbsp; :: *State :== Int ;
<br>&nbsp;&nbsp;&nbsp; :: IntPointer :== Int
<br>&nbsp;)
<p>A type synonym can be used before its definition (and after its definition
as well of course). In the type of store_int we can now show which parameters
are pointers:
<p>Clean (store_int :: IntPointer Int Int -> IntPointer )
<p>2.6 ADDING ADDITIONAL PARAMETERS AND RESULTS IN CLEAN
<p>Functions written in C often have side effects. It is therefore often
necessary to execute these functions in a specific order. Because Clean
is lazy, and because the order of evaluation is not defined, this is not
easy in Clean. For example, in example_int2_main.c we use the guard | s==s
to evaluate s before deallocating the allocated memory.
<br>A better way is to specify the order in which to execute C functions
by passing a unique state. This is made possible with htoclean by adding
additional arguments and return values, that are hidden in C. This is specified
by adding extra arguments at the end of the arguments list, and extra return
values, also at the end. The number of extra arguments and return values
should be the same, and the arguments and results should be passed in the
same order, and each extra argument should have the same type as the corresponding
return value. For example, we can use:
<p>Clean (store_int :: IntPointer Int Int State -> (IntPointer,State) )
<p>to add a State argument and result. The type of the store_int function
in C does not have to be changed. By adding this State to all functions
in example_int2.h, we obtain example_int3.h (see the Examples folder or
the appendix). Now the guard | s==s is no longer required, because s is
always evaluated before my_free is called, because of the (strict) state
parameter. Unfortunately, we still need a guard to force the evaluation
of my_free, because the Start function does not return the state (see example_int3_main.icl).
<p>We could decide to remove the IntPointer result from store_int, because
it has the same value as the first argument. Then the type of store_int
changes to:
<p>void store_int (int *p,int offset,int value);
<p>Notice that the type of the result is void. So now we can also call
C functions that do not return a value. This is not possible without adding
additional parameters, because in Clean all functions yield a result.
<br>Using an infix macro, we can even hide the state parameters and result
and write the store_int calls in the right order (see example_int4_main.icl).
<p>2.7 TUPLES
<p>Tuples can be passed to C functions by specifying a tuple with Clean
( ). Such a tuple is unboxed before the C function is called. So the C
function is not passed a tuple, but the elements of the tuple. For example:
<p>int f (int tuple_element1,int tuple_element2);
<br>Clean (f :: (Int,Int) -> Int)
<p>A function can also return tuples, as we have already seen in the previous
section. In C the elements of the tuple are returned using pointers. For
each element in the tuple, an argument is added at the end of the arguments
of the C function, that contains the address of the bytes on the stack
where the result has to be stored. For example (see example_tuple1.h):
<p>Clean (::ComplexInt:==(Int,Int))
<br>void make_complex_int (int re,int im,int *re_p,int *im_p);
<br>Clean (make_complex_int :: Int Int -> ComplexInt)
<p>The function is implemented as:
<p>void make_complex_int (int re,int im,int *re_p,int *im_p)
<br>{
<br>&nbsp;&nbsp;&nbsp; *re_p=re;
<br>&nbsp;&nbsp;&nbsp; *im_p=im;
<br>}
<p>The first element of the tuple may also be returned as the result of
the function instead, but not if it is a String.
<p>2.8 STRINGS
<p>Strings can be passed to and returned by C functions. The type of these
strings in C is the type CleanString. In Clean ( ) type specifications
the predefined synonym type String has to be used, and not {#Char}. {#Char}
is used for CleanCharArray (see below). The type CleanString is defined
in the file Clean.h, and is a pointer to a 32 bit integer containing the
number of characters in the string, followed by the characters (8 bit,unsigned).
The string does not end with a '\0' character. So:
<p>struct {
<br>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; clean_string_length;
<br>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; clean_string_characters[clean_string_length];
<br>} *CleanString;
<p>The following macros are defined in Clean.h to access CleanStrings:
<br>CleanStringLength (clean_string)
<br>&nbsp;&nbsp;&nbsp; number of characters in the clean_string.
<br>CleanStringCharacters (clean_string)
<br>&nbsp;&nbsp;&nbsp; a pointer to the characters of the clean_string.
<br>CleanStringVariable (clean_string,string_length)
<br>&nbsp;&nbsp;&nbsp; defines variable clean_string with length string_length,
<br>&nbsp;&nbsp;&nbsp; before using the clean_string variable, cast to
CleanString, except for the macros above.
<br>CleanStringSizeInts (string_length)
<br>&nbsp;&nbsp;&nbsp; size of *CleanString in integers.
<br>CleanStringSizeBytes (string_length)
<br>&nbsp;&nbsp;&nbsp; size of *CleanString in bytes.
<p>When a String in Clean is passed to C, the String is not copied, but
an offset is added to the address of the string in the heap of Clean, and
this address is passed to C. Consequently, after returning from C, this
address can no longer be used, because the string may be moved or deallocated
by the garbage collector. The size of the string should not be modified.
If the string is still needed in the C code after returning from C, you
should make a copy and use this copy instead.
<p>When a CleanString is returned from C, a copy of the string will be
created in the Clean heap, and this copy will be used by Clean. If the
string was allocated in C, for example using malloc, it should be deallocated
in C when it no longer used, it is not automatically deallocated by Clean.
<p>CleanString can not be the result type of a C function. CleanStrings
should always be returned by a *CleanString argument from C. For example
(example_string1.h):
<p>void hello_string_from_c (CleanString *);
<br>Clean (hello_string_from_c :: -> String)
<p>The characters of Strings passed to C can be modified, but if the String
is not unique, this causes side effects. This problem can be prevented
by making sure the string is unique before calling the C code. See string_to_uppercase
in example_string1_main.icl for an example.
<p>2.9 ARRAYS
<p>The following array types can be passed to C functions: {#Int}, {#Real}
and {#Char}. They cannot be yielded by C functions.
<br>The type of these arrays in C are CleanIntArray, CleanRealArray and
CleanCharArray. These types are defined in the file Clean.h as:
<p>typedef int *CleanIntArray;
<br>typedef double *CleanRealArray;
<br>typedef unsigned char *CleanCharArray;
<p>so the elements of these arrays can be accessed directly in C using
the [ ] or * operators. The size (number of elements) can be obtained using
the following macros (in Clean.h):
<p>CleanIntArraySize(clean_array) returns the size (number of elements)
of the clean_int_array
<br>CleanRealArraySize(clean_real_array) returns the size (number of elements)
of the clean_real_array
<br>CleanCharArraySize(clean_char_array) returns the size (number of elements)
of the clean_char_array
<p>See example_array1_main.icl for an example.
<p>When an array in Clean is passed to C, the array is not copied, but
an offset is added to the address of the array in the heap of Clean, and
this address is passed to C. Consequently, after returning from C, this
address can no longer be used, because the array may be moved or deallocated
by the garbage collector. The size of the array should not be modified.
If the array is still needed in the C code after returning from C, you
should make a copy and use this copy instead.
<p>2.10 STRUCT
<p>struct definitions are not supported by htoclean. Furthermore htoclean
cannot interface with C functions that accept struct arguments or return
results of type struct.
<br>But pointers to structures are supported. These are represented by
integers in Clean.
<p>2.11 TYPEDEFS
<p>typedefs of int, real, pointer and enum types are supported by htoclean.
Usually a Clean synonym type should be defined with the same name as the
type in C. For example:
<p>typedef int State;
<br>Clean (::*State:==Int)
<br>or:
<br>typedef struct my_struct *MyStruct;
<br>Clean (::MyStruct:==Int)
<p>2.12 ENUMURATION TYPES
<p>C enum types can be used in .h files for htoclean. For example (see
example_enum1.h):
<p>enum { ADD,SUB,AND,OR };
<p>In Clean a macro is generated for each constant. So in this example:
ADD:==0 and SUB:==1. The enum type can not have a name and = can not be
used to define the value of a constant.
<p>2.13 #DEFINES
<p>#defines of decimal and hexadecimal integer constants and character
constants may be defined in .h files for htoclean. The htoclean tool will
generate a macro in Clean for each #defined definition. \ characters in
character constants are not supported. See example_const1.h.
<p>2.14 REALS
<p>The types double (in C) and Real (in Clean) are supported.
<p>2.15 IMPORT AND INCLUDE
<p>To import the Clean module 'clean_module' use:
<br>Clean (import clean_module)
<p>htoclean will read the file clean_module.dcl, so that types defined
in this module can be used. The contents of this file are not included
in the output of htoclean. Instead 'import clean_module' is added to the
output file. An example can be found in example_tuple1.h and example_type1.h.
<p>To include the .h file 'prototypes.h' use:
<br>#include "prototypes.h"
<br>or:
<br>#include &lt;prototypes.h>
<p>htoclean will read the file prototypes.h and use the contents of the
file as if they where written in the file that included this .h file. No
'import protypes' is add to the Clean code produced by htoclean.
<p>2.16 #PRAGMA
<p>Lines starting with #pragma are ignored by htoclean.
<p><font size=+1>3. COMPILING AND LINKING</font>
<p>3.1 COMPILING THE C PROGRAM / SUPPORTED C COMPILERS
<p>On unix systems a c program (in this case example_int1_c.c) is compiled
with cc, for example:
<br>cc -O -c example_int1_c.c
<br>The C compiler generates an object file: example_int1_c.o.
<br>On windows system a C compiler has to be used that generates ECOFF
object files, for example Visual C++ and Metrowerks CodeWarrior. The Watcom
C compiler can not be used. The gnu compiler might work. We have tested
Visual C versions 4 and 5. The example_int1_c.obj object file can be generated
by compiling the .c file using the developer studio, or by invoking the
C compiler from the MSDOS prompt with:
<br>cl /c /O2 /Gy example_int1_c.c
<br>On the PowerMacintosh Metrowerks CodeWarrior or MrC can be used. Because
CodeWarrior does not generate separate object files, a library has to be
build instead. This library should contain only object files, no libraries.
<p>3.2 LINKING C OBJECT FILES WITH CLEAN
<p>The module example_int1_main.icl uses this add function to add two numbers.
To compile and link this program with the CleanIDE, create a project with
this module as main module, and add the object file or library (for PowerPC
CodeWarrior) to the list of Object Modules in the Link Options dialogue.
<p>On unix systems the program can be compiled with clm using:
<br>clm -l example_int1_c.o example_int1_main
<p>3.3 LINKING DLL'S / SHARED LIBRARIES
<p>To link with shared libraries on Unix systems with clm, use -l -lname,
where name is the name of the shared library (without the lib prefix and
.so suffix). clm will pass -lname to ld (the linker), which reads the file
libname.so. clm does not interpret the argument after -l, so other parameters
can be passed to the linker in this way as well.
<br>To link with shared libraries using the CleanIDE on Unix systems, add
the file libname.so to the Libraries of the Options/Link Options dialogue.
Static shared libraries (.a files) should be added to the Object Modules
of this dialogue.
<p>The Clean linker for Windows and MacOS does not support importing symbols
from DLLs/shared libraries using object files (import libraries), because
some relocations are not implemented. Instead symbols from a DLL/shared
library are imported using an ascii file that lists the symbols that are
exported by a DLL/shared library. The first line of such a file contains
the name of the DLL/shared library (with .dll extension on windows, usually
no full pathname), the next lines contain the names of the exported symbols
(only functions), each symbol on one line, spaces and comments are not
permitted. Examples can be found in the 'Clean System Files' folder of
the StdEnv. On the PowerMacintosh the files library0, library1 and library2
contain symbols exported by the InterfaceLib, StdCLib and MathLib. On Windows
the files kernel_library, gdi_library and user_library contain symbols
exported by kernel32.dll, gdi32.dll and user32.dll. These files do not
contain all symbols exported by these DLL/libraries, missing symbols can
be added with an editor. So to link with another DLL/library, such a text
file has to be written, and then added to the Libraries of the Options/Link
Options dialogue of the CleanIDE.
<p><font size=+1>4 IMPLEMENTATION OF HTOCLEAN</font>
<p>4.1 CCALL
<p>This section contains some information on the implementation of htoclean.
You don't need to know this to use htoclean.
<p>To interface Clean and C, htoclean uses the ABC abstract machine instruction
'ccall'. ABC instructions can be written in Clean using 'code { ABC instructions
}'. Clean programmers should not use code{} and ABC instructions. This
construct was added to make it easier for us to write the standard library
and generate interfaces to the operating system/C code. Incorrect use of
code{} and ABC instructions will often result in programs that crash. This
construct may change/disappear in future versions of Clean without notice.
<p>Each Clean function generated by htoclean consists of a function type
and a function alternative using code { }. All the arguments and tuples
of the function type are made strict by htoclean using ! annotations. The
function alternative consists of code { ccall c_function_name type_string
}. The first characters of the type string specify the types of the input
parameters, then a ':' seperator follows, then a character that specifies
the result type of the function, then follow (optional) characters that
specify the types of the output parameters. I is used to specify an Int,
R for Real, S for String and V for void. V is only allowed for the result
type. This specification may be followed by a ':' separator and characters
describing the additional Clean input/output parameters that are not visible
in C. These characters use the same coding of types as above, V is of course
not allowed.
<p>For example to call:
<br>void f (int,int *,int *);
<p>with an extra Int parameter, htclean generates:
<br>f :: !Int !*Int -> (!Int,!Int,!*Int);
<br>f a1 a2 = code {
<br>&nbsp;&nbsp;&nbsp; ccall f "I:VII:I"
<br>};
<br>&nbsp;
<li>
<font size=+1>5 FUTURE WORK</font></li>

<blockquote>
<li>
Support the calling convention used by most DLL's on windows where the
callee pops the arguments, instead of the caller. This is already supported
by the 'ccall' abc instruction, by adding a 'P' at the beginning of the
string with type information.</li>

<li>
Integrate htoclean in the CleanIDE.</li>

<li>
Allow output parameters before the last input parameter.</li>

<li>
Garbage collector support for deallocating memory allocated in C.</li>

<li>
Call Clean functions from C.</li>
</blockquote>
<font size=+1>APPENDIX</font>
<p>A. TYPE CONVERSION
<br>&nbsp;
<table BORDER=3 CELLSPACING=3 CELLPADDING=3 >
<tr>
<td>C type:</td>

<td>Clean type:</td>
</tr>

<tr>
<td>-------------</td>

<td>------------</td>
</tr>

<tr>
<td>int</td>

<td>Int,Bool,Char</td>
</tr>

<tr>
<td>char</td>

<td>Char</td>
</tr>

<tr>
<td>double</td>

<td>Real</td>
</tr>

<tr>
<td>CleanString</td>

<td>String</td>
</tr>

<tr>
<td>CleanIntArray</td>

<td>{#Int}</td>
</tr>

<tr>
<td>CleanRealArray</td>

<td>{#Real}</td>
</tr>

<tr>
<td>CleanCharArray</td>

<td>{#Char}</td>
</tr>

<tr>
<td>AnyType *</td>

<td>Int</td>
</tr>
</table>

<p>Comment starts with // or /*, and ends with a newline (for //) or with
*/ (for /*).
<p>B. GRAMMAR OF .H FILE
<p>interface-file:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {interface-declaration}
<p>interface-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-function-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-typedef-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-define-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-enum-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-include
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-pragma
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-declarations
<p>c-define-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define identifier integer_or-char-denotation
<p>integer_or-char-denotation:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer-denotation
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hexadecimal-integer-denotation
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char-denotation
<p>integer-denotation:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [+|-] {0-9}+
<p>hexadecimal-integer-denotation:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [+|-] 0x{0-9|a-f|A-F}+
<p>char-denotation:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' any-char '
<p>c-enum-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum { enum-constants }
;
<p>enum-constants:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier , enum-constants
<p>c-include:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include " file-name "
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt; file-name
>
<p>file-name: {any-char/-("|>)}
<p>c-pragma:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma {any-char/-(\n)}
<p>c-typedef-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef c-type typedef-name
;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef c-enum-declaration
typedef-name ;
<p>c-type:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-basic-type {*}
<p>c-basic-type
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CleanString
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CleanIntArray
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CleanRealArray
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CleanCharArray
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct struct-name
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef-name
<p>typedef-name:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identfier
<p>c-function-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-type c-function-name (
c-function-argument-list ) ;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-type c-function-name (
void ) ;
<p>c-function-name:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<p>c-function-argument-list:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-function-argument
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-function-argument , c-function-argument-list
<p>c-function-argument:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-type
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c-type c-argument-name.
<p>c-argument-name:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier.
<p>clean-declarations:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Clean ( clean-declaration-list
) [;]
<p>clean-declaration-list:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-declaration ; clean-declaration-list
<p>clean-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-function-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-type-synonym-declaration
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-import
<p>clean-function-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-function-name :: {clean-function-argument}
-> clean-type
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-function-name :: clean-type
<p>clean-function-name:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; identifier
<p>clean-function-argument:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-type
<p>clean-type:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Char
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bool
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Real
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {#Int}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {#Real}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {#Char}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-type-name
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( clean-type-tuple-arguments
)
<p>clean-type-tuple-arguments:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-type
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clean-type , clean-type-tuple-arguments
<p>clean-type-synonym-declaration:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: [*] clean-type-name :==
clean-type
<p>clean-type-name :: uppercase-identifier
<p>uppercase-identifier: (A-Z){identifier-char}
<p>identifier: {identifier-char}+
<p>identifier-char: (a-z|A-Z|0-9|_)
<p>clean-import:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import module-name-list
<p>module-name-list:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; module-name
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; module-name , module-name-list
<p>module-name: {any-char/-( |,|)|;)}
<p>C. EXAMPLE CODE
<p>File: example_const1.h
<p>#define ADD 10
<br>#define SUB 20
<br>#define AND 30
<br>#define OR&nbsp; 40
<p>#define ADD_OP '+'
<br>#define SUB_OP '-'
<br>#define AND_OP '&amp;'
<br>#define OR_OP&nbsp; '|'
<p>int compute (int operator,int arg1,int arg2);
<p>File: example_const1_c.c
<p>#include "Clean.h"
<br>#include "example_const1.h"
<p>int compute (int operator,int arg1,int arg2)
<br>{
<br>&nbsp;switch (operator){
<br>&nbsp; case ADD: return arg1+arg2;
<br>&nbsp; case SUB: return arg1-arg2;
<br>&nbsp; case AND: return arg1&amp;arg2;
<br>&nbsp; case OR:&nbsp; return arg1|arg2;
<br>&nbsp;}
<br>&nbsp;return 0;
<br>}
<p>File: example_const1_main.icl
<p>module example_const1_main;
<p>import example_const1;
<p>char_to_op ADD_OP = ADD;
<br>char_to_op SUB_OP = SUB;
<br>char_to_op AND_OP = AND;
<br>char_to_op OR_OP&nbsp; = OR;
<p>Compute op a1 a2 = compute (char_to_op op) a1 a2;
<p>Start = (Compute '+' 1 2,Compute '-' 1 2,Compute '&amp;' 1 2,Compute
'|' 1 2);
<p>File: example_enum1.h
<p>enum {
<br>&nbsp;ADD,SUB,AND,OR
<br>};
<p>int compute (int operator,int arg1,int arg2);
<p>File: example_enum1_c.c
<p>#include "Clean.h"
<br>#include "example_enum1.h"
<p>int compute (int operator,int arg1,int arg2)
<br>{
<br>&nbsp;switch (operator){
<br>&nbsp; case ADD: return arg1+arg2;
<br>&nbsp; case SUB: return arg1-arg2;
<br>&nbsp; case AND: return arg1&amp;arg2;
<br>&nbsp; case OR:&nbsp; return arg1|arg2;
<br>&nbsp;}
<br>&nbsp;return 0;
<br>}
<p>File: example_enum1_main.icl
<p>module example_enum1_main;
<p>import example_enum1;
<p>Start = (compute ADD 1 2,compute SUB 1 2,compute AND 1 2,compute OR
1 2);
<p>File: example_int1.h
<p>int add (int v1,int v2); /* returns v1+v2 */
<p>File: example_int1_c.c
<p>#include "example_int1.h"
<p>int add (int v1,int v2)
<br>{
<br>&nbsp;return v1+v2;
<br>}
<p>File: example_int1_main.icl
<p>module example_int1_main;
<p>import example_int1;
<p>Start = add 1 2;
<p>File: example_int2.h
<p>void *my_malloc (int size_in_bytes); /* allocates size_in_bytes bytes
*/
<br>int my_free (void*); /* frees memory allocated by my_malloc */
<p>int *store_int (int *p,int offset,int value); /* p [offset] = value
*/
<p>int add_p (int *p1,int *p2); /* returns *p1 + *p2 */
<p>File: example_int2_c.c
<p>#include &lt;Memory.h>
<p>#include "example_int2.h"
<br>/* or:
<br># include "Clean.h"
<br># include "example_int3.h"
<br>*/
<p>void *my_malloc (int size_in_bytes)
<br>{
<br>&nbsp;return NewPtr (size_in_bytes);
<br>}
<p>int my_free (void *p)
<br>{
<br>&nbsp;DisposePtr (p);
<br>&nbsp;return 0;
<br>}
<p>int *store_int (int *p,int offset,int value)
<br>{
<br>&nbsp;p[offset]=value;
<br>&nbsp;return p;
<br>}
<p>int add_p (int *p1,int *p2)
<br>{
<br>&nbsp;return *p1 + *p2;
<br>}
<p>File: example_int2_main.icl
<p>module example_int2_main;
<p>import StdEnv;
<p>import example_int2;
<p>Start
<br>&nbsp;# p=my_malloc (2&lt;&lt;2); // allocate memory for 2 integers;
<br>&nbsp;| p==0
<br>&nbsp; = abort "Out of memory";
<br>&nbsp;# p=store_int p 0 10; // p[0]=10
<br>&nbsp;# p=store_int p 1 20; // p[1]=20
<br>&nbsp;# s=add_p (p+0) (p+4); // add p[0] and p[1]
<br>&nbsp;| s==s // force evaluation of add, before deallocating memory
!
<br>&nbsp;# r=my_free p; // release_memory
<br>&nbsp;| r&lt;>0 // force evaluation of my_free and test for error
<br>&nbsp; = abort "Function my_free failed";
<br>&nbsp;= s;
<p>File: example_int3.h
<p>Clean (
<br>&nbsp;:: *State :== Int ;
<br>&nbsp;:: IntPointer :== Int
<br>&nbsp;)
<p>void *my_malloc (int size_in_bytes); /* allocates size_in_bytes bytes
*/
<br>Clean (my_malloc :: Int State -> (IntPointer,State) )
<p>int my_free (void*); /* frees memory allocated by my_malloc */
<br>Clean (my_free :: IntPointer State -> (Int,State) )
<p>int *store_int (int *p,int offset,int value); /* p [offset] = value
*/
<br>Clean (store_int :: IntPointer Int Int State -> (IntPointer,State)
)
<p>int add_p (int *p1,int *p2); /* returns *p1 + *p2 */
<br>Clean (add_p :: IntPointer IntPointer State -> (Int,State) )
<p>File: example_int3_main.icl
<p>module example_int3_main;
<p>import StdEnv;
<p>import example_int3;
<p>Start
<br>&nbsp;# state=0;
<br>&nbsp;# (p,state) = my_malloc (2&lt;&lt;2) state; // allocate memory
for 2 integers;
<br>&nbsp;| p==0
<br>&nbsp; = abort "Out of memory";
<br>&nbsp;# (p,state) = store_int p 0 10 state; // p[0]=10
<br>&nbsp;# (p,state) = store_int p 1 20 state; // p[1]=20
<br>&nbsp;# (s,state) = add_p (p+0) (p+4) state; // add p[0] and p[1]
<br>&nbsp;# (r,state) = my_free p state; // release_memory
<br>&nbsp;| r&lt;>0 // force evaluation of my_free and test for error
<br>&nbsp; = abort "Function my_free failed";
<br>&nbsp;= s;
<p>File: example_int4.h
<p>Clean (
<br>&nbsp;:: *State :== Int ;
<br>&nbsp;:: IntPointer :== Int
<br>&nbsp;)
<p>void *my_malloc (int size_in_bytes); /* allocates size_in_bytes bytes
*/
<br>int my_free (void*); /* frees memory allocated by my_malloc */
<br>void store_int (int *p,int offset,int value); /* p [offset] = value
*/
<br>int add_p (int *p1,int *p2); /* returns *p1 + *p2 */
<p>Clean (
<br>&nbsp;my_malloc :: Int State -> (IntPointer,State);
<br>&nbsp;my_free :: IntPointer State -> (Int,State) ;
<br>&nbsp;store_int :: IntPointer Int Int State -> State ;
<br>&nbsp;add_p :: IntPointer IntPointer State -> (Int,State)
<br>&nbsp;)
<p>File: example_int4_c.c
<p>#include &lt;Memory.h>
<p>#include "Clean.h"
<br>#include "example_int4.h"
<p>void *my_malloc (int size_in_bytes)
<br>{
<br>&nbsp;return NewPtr (size_in_bytes);
<br>}
<p>int my_free (void *p)
<br>{
<br>&nbsp;DisposePtr (p);
<br>&nbsp;return 0;
<br>}
<p>void store_int (int *p,int offset,int value)
<br>{
<br>&nbsp;p[offset]=value;
<br>}
<p>int add_p (int *p1,int *p2)
<br>{
<br>&nbsp;return *p1 + *p2;
<br>}
<p>File: example_int4_main.icl
<p>module example_int4_main;
<p>import StdEnv;
<p>import example_int4;
<p>(>:) infixl;
<br>(>:) f g:==g f;
<p>Start
<br>&nbsp;# state=0;
<br>&nbsp;# (p,state) = my_malloc (2&lt;&lt;2) state; // allocate memory
for 2 integers;
<br>&nbsp;| p==0
<br>&nbsp; = abort "Out of memory";
<br>&nbsp;# (s,state) = state
<br>&nbsp;&nbsp;&nbsp;&nbsp; >: store_int p 0 10 // p[0]=10
<br>&nbsp;&nbsp;&nbsp;&nbsp; >: store_int p 1 20&nbsp; // p[1]=20
<br>&nbsp;&nbsp;&nbsp;&nbsp; >: add_p (p+0) (p+4); // add p[0] and p[1]
<br>&nbsp;# (r,state) = my_free p state; // release_memory
<br>&nbsp;| r&lt;>0 // force evaluation of my_free and test for error
<br>&nbsp; = abort "Function my_free failed";
<br>&nbsp;= s;
<p>File: example_string1.h
<p>void spaces_string (int n_spaces,CleanString*);
<br>Clean (spaces_string :: Int -> String)
<p>void hello_string_from_c (CleanString *);
<br>Clean (hello_string_from_c :: -> String)
<p>int string_to_uppercase_with_side_effect (CleanString);
<br>Clean (string_to_uppercase_with_side_effect :: String -> Int)
<p>File: example_string1_c.c
<p>#include "Clean.h"
<br>#include "example_string1.h"
<p>#define MAX_SPACES_STRING_SIZE 1024
<p>static CleanStringVariable(result_string,MAX_SPACES_STRING_SIZE);
<p>void spaces_string (int n_spaces,CleanString *result_string_p)
<br>{
<br>&nbsp;char *result_string_characters;
<br>&nbsp;int i;
<p>&nbsp;if (n_spaces>MAX_SPACES_STRING_SIZE)
<br>&nbsp; n_spaces=MAX_SPACES_STRING_SIZE;
<p>&nbsp;CleanStringLength(result_string) = n_spaces;
<p>&nbsp;result_string_characters = CleanStringCharacters(result_string);
<p>&nbsp;for (i=0; i&lt;n_spaces; ++i)
<br>&nbsp; result_string_characters[i]=' ';
<p>&nbsp;*result_string_p = (CleanString)result_string;
<br>}
<p>static struct {int length; char chars[5+1]; } hello_string = {5,"hello"};
<p>void hello_string_from_c (CleanString *hello_string_p)
<br>{
<br>&nbsp;*hello_string_p=(CleanString)&amp;hello_string;
<br>}
<p>int string_to_uppercase_with_side_effect (CleanString string)
<br>{
<br>&nbsp;int i,length,n_lowercase_characters;
<br>&nbsp;char *characters;
<p>&nbsp;length=CleanStringLength(string);
<br>&nbsp;characters=CleanStringCharacters(string);
<br>&nbsp;n_lowercase_characters=0;
<p>&nbsp;for (i=0; i&lt;length; ++i){
<br>&nbsp; char c;
<p>&nbsp; c=characters[i];
<br>&nbsp; if ((unsigned)(c-'a')&lt;26u){
<br>&nbsp;&nbsp; characters[i]=c+('A'-'a');
<br>&nbsp;&nbsp; ++n_lowercase_characters;
<br>&nbsp; }
<br>&nbsp;}
<p>&nbsp;return n_lowercase_characters;
<br>}
<p>File: example_string1_main.icl
<p>module example_string1_main;
<p>import StdEnv;
<br>import example_string1;
<p>/*
<br>&nbsp;string_to_uppercase_with_side_effect updates the string. This
is only allowed if this
<br>&nbsp;is the only reference to the string (i.e. the string is unique).
<br>&nbsp;We cannot make the string unique with the htoclean tool (unless
we copy the string). Therefore,
<br>&nbsp;we define string_to_uppercase to make sure that the string is
unique and use this function instead.
<br>&nbsp;We can return the string as a unique string by cheating using
observation typing.
<br>*/
<p>string_to_uppercase :: !*String -> (!Int,!*String);
<br>string_to_uppercase string
<br>&nbsp;#! n=string_to_uppercase_with_side_effect string; // evaluate
and pretend we observe the string
<br>&nbsp;= (n,string);
<p>Start = (spaces_string 18+++"vwxyz\n"+++
<br>&nbsp;&nbsp; spaces_string 20+++"xyz\n",
<br>&nbsp;&nbsp; hello_string_from_c,"\n",
<br>&nbsp; string_to_uppercase {'A','a','B','b','C','c'});
<br>// we use {'A','a','B','b','C','c'} because "AaBbCc" is not unique
<p>File: example_tuple1.h
<p>Clean (import example_type1)
<p>void make_complex_int (int re,int im,int *re_p,int *im_p);
<br>Clean (make_complex_int :: Int Int -> ComplexInt)
<p>void add_complex_int (int re1,int im1,int re2,int im2,int *re_p,int
*im_p);
<br>Clean (add_complex_int :: ComplexInt ComplexInt -> ComplexInt)
<p>File: example_tuple1_c.c
<p>#include "Clean.h"
<br>#include "example_tuple1.h"
<p>void make_complex_int (int re,int im,int *re_p,int *im_p)
<br>{
<br>&nbsp;*re_p=re;
<br>&nbsp;*im_p=im;
<br>}
<p>void add_complex_int (int re1,int im1,int re2,int im2,int *re_p,int
*im_p)
<br>{
<br>&nbsp;*re_p=re1+re2;
<br>&nbsp;*im_p=im1+im2;
<br>}
<p>File: example_tuple1_main.icl
<p>module example_tuple1_main;
<p>import StdEnv;
<br>import example_tuple1;
<p>Start = add_complex_int (make_complex_int 1 2) (make_complex_int 3 4);
<p>File: example_type1.h
<p>Clean (::ComplexInt:==(Int,Int))
<p>File: example_array1.h
<p>int sum_int_array (CleanIntArray a);
<br>Clean (sum_int_array :: {#Int} -> Int)
<p>double sum_real_array (CleanRealArray a);
<br>Clean (sum_real_array :: {#Real} -> Real)
<p>int first_different_char_index (CleanCharArray a1,CleanCharArray a2);
<br>Clean (f :: {#Char} {#Char} -> Int)
<p>File: example_array1_c.c
<p>#include "Clean.h"
<p>int sum_int_array (CleanIntArray a)
<br>{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum,s,i;
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s=CleanIntArraySize (a);
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum=0;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;s; ++i)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sum+=a[i];
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sum;
<br>}
<p>double sum_real_array (CleanRealArray a)
<br>{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double sum;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s,i;
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s=CleanRealArraySize (a);
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum=0;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;s; ++i)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sum+=a[i];
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sum;
<br>}
<p>int first_different_char_index (CleanCharArray a1,CleanCharArray a2)
<br>{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int s1,s2,i;
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s1=CleanCharArraySize (a1);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s2=CleanCharArraySize (a2);
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;s1 &amp;&amp;
i&lt;s2; ++i)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (a1[i]!=a2[i])
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return i;
<br>&nbsp;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (s1!=s2)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return i;
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return -1;
<br>}
<p>File: example_array1_main.icl
<p>module example_array1_main;
<p>import StdEnv;
<br>import example_array1;
<p>Start = (sum_int_array {1,2,3},
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sum_real_array {1.5,2.6,3.7},
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
first_different_char_index "abcdef" "abzdef")
<br>&nbsp;
</body>
</html>
