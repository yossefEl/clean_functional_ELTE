<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Clean Language Report</title>
</head>
<body style="font-family:Helvetica">
<div><div style="position: absolute;"><svg width="355.555555555556" height="177.777777777778">
<path d="M49.7777777777778 7.32929319639176 h280.888888888889 v141.785858051661 h-280.888888888889 Z M64 33.9959598630584 h252.444444444444 v88.4525247183276 h-252.444444444444 Z" stroke="none" fill="#3F87AF" fill-rule="evenodd"/>
<path d="M64 111.781817914719 h252.444444444444 v10.6666666666667 h-252.444444444444 Z" stroke="none" fill="#8C96A0"/>
<path d="M64 33.9959598630584 h252.444444444444 v10.6666666666667 h-252.444444444444 Z" stroke="none" fill="#8C96A0"/>
<path d="M64 44.6626265297251 h252.444444444444 v67.1191913849942 h-252.444444444444 Z" stroke="none" fill="#FFFFFF"/>
<path d="M99.1179703874409 137.550135143052 C93.2711853763986 133.302197180425,88.084448516421 128.213312506961,83.725936053644 122.448484581386 L110.089961763567 122.448484581386 Z" stroke="none" fill="#8C96A0"/>
<path d="M99.1179703874409 18.8943093013927 C93.2711853763986 23.1422472640192,88.084448516421 28.2311319374834,83.725936053644 33.9959598630584 L110.089961763567 33.9959598630584 Z" stroke="none" fill="#8C96A0"/>
<path d="M126.968649704419 100.555210486665 C109.380820468897 87.7769045717629,109.380820468897 61.5564287615705,126.968649704419 48.7781228466684 L116.780371998016 34.7551616108359 C89.6658019265873 54.45504989631,89.6658019265873 94.8782834370233,116.780371998016 114.578171722497 Z" stroke="none" fill="#8C96A0"/>
<path d="M113.645517319123 118.89292902583 C83.5996423751073 97.0633230878727,83.5996423751073 52.2700102454607,113.645517319123 30.4404043075029 L102.673525942996 15.3387537458372 C62.3680839449271 44.6223714674879,62.3680839449271 104.710961865845,102.673525942996 133.994579587496 Z" stroke="none" fill="#8C96A0"/>
<path d="M123.413094148863 104.110766042221 C105.825264913342 91.3324601273184,105.825264913342 65.111984317126,123.413094148863 52.3336784022239 L113.22481644246 38.3107171663915 C86.1102463710318 58.0106054518656,86.1102463710318 98.4338389925788,113.22481644246 118.133727278053  Z" stroke="none" fill="#3F87AF"/>
<path d="M110.089961763567 122.448484581386 C80.0440868195518 100.618878643428,80.0440868195518 55.8255658010162,110.089961763567 33.9959598630584L83.725936053644 33.9959598630584 C63.9432065006372 60.1617750913602,63.9432065006372 96.2826693530842,83.725936053644 122.448484581386" stroke="none" fill="#3F87AF"/>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="145.777777777778" y="103.111111111111" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="144.888888888889" y="102.222222222222" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="144" y="101.333333333333" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="143.111111111111" y="100.444444444444" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="142.222222222222" y="99.5555555555556" fill="#3F87AF">Clean</text>
</svg>
</div><h1 style="text-align:right;background-color:#9999FF;"><a id="_9"><br>Chapter 9<br><br>Uniqueness Typing</a></h1></div>
<p style="text-align:justify;">Although CLEAN is purely functional, operations with side-effects (I/O operations, for instance) are permitted. To achieve this without violating the semantics, the classical types are supplied with so called uniqueness attributes. If an argument of a function is indicated as unique, it is guaranteed that at run-time the corresponding actual object is local, i.e. there are no other references to it. Clearly, a destructive update of such a "unique object" can be performed safely.</p>
<p style="text-align:justify;">The uniqueness type system makes it possible to define direct interfaces with an operating system, a file system (updating persistent data), with GUI's libraries, it allows to create arrays, records or user defined data structures that can be updated destructively. The time and space behavior of a functional program therefore greatly benefits from the uniqueness typing.</p>
<p style="text-align:justify;">Uniqueness types are deduced automatically. Type attributes are polymorphic: attribute variables and inequalities on these variables can be used to indicate relations between and restrictions on the corresponding concrete attribute values.</p>
<p style="text-align:justify;">Sometimes the inferred type attributes give some extra information on the run-time behavior of a function. The uniqueness type system is a transparent extension of classical typing that means that if one is not interested in the uniqueness information one can simply ignore it.</p>
<p style="text-align:justify;">Since the uniqueness typing is a rather complex matter we explain this type system and the motivation behind it in more detail. The first <span style="color:blue;"><a href="#_9.1">Section (9.1)</a></span> explains the basic motivation for and ideas behind uniqueness typing. <span style="color:blue;"><a href="#_9.2">Section 9.2</a></span> focuses on the so-called uniqueness propagation property of (algebraic) type constructors. Then we show how new data structures can be defined containing unique objects (<span style="color:blue;"><a href="#_9.3">Section 9.3)</a></span>. Sharing may destroy locality properties of objects. In <span style="color:blue;"><a href="#_9.4">Section 9.4</a></span> we describe the effect of sharing on uniqueness types. In order to maintain referential transparency, it appears that function types have to be treated specially. The last <span style="color:blue;"><a href="#_9.5">Section (9.5)</a></span> describes the combination of uniqueness typing and overloading. Especially, the subsections on constructor classes and higher-oder type definitions are very complex: we suggest that the reader skips these sections at first instance.</p>
<h2 style="background-color:#9999FF;"><a id="_9.1">9.1 Basic Ideas behind Uniqueness Typing</a></h2>
<p style="text-align:justify;">The <i>uniqueness typing</i> is an extension of classical Milner/Mycroft typing. In the uniqueness type system <i>uniqueness type attributes</i>  are attached to the classical types. Uniqueness type attributes appear in the <i>type specifications of functions</i> <span style="color:blue;"><a href="#_9.4">see 9.4</a></span>) but are also permitted in the definitions of <i>new data types </i>(<span style="color:blue;"><a href="#_9.3">see 9.3</a></span>). A classical type can be prefixed by one of the following uniqueness type attributes:</p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">Type</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8692929292929%;padding:0 0 4px 0;" colspan="3">{BrackType}+</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">BrackType</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8692929292929%;padding:0 0 4px 0;" colspan="3">[Strict] [UnqTypeAttrib] SimpleType</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">UnqTypeAttrib</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:27.0690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>*</b></span></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:42.78%;padding:0 0 4px 0;">// type attribute "unique"</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">|</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:27.0690909090909%;padding:0 0 4px 0;">UniqueTypeVariable<span style="font-family:courier;color:#993300;"><b>:</b></span></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:42.78%;padding:0 0 4px 0;">// a type attribute variable</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">|</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:27.0690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>.</b></span></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:42.78%;padding:0 0 4px 0;">// an anonymous type attribute variable</td></tr>
</table><p></p>
<p style="text-align:justify;">The basic idea behind uniqueness typing is the following. Suppose a function, say <span style="font-family:courier;">F</span>, has a unique argument (an argument with type <span style="font-family:courier;">*&sigma;</span>, for some <span style="font-family:courier;">&sigma;</span>). This attribute imposes an additional restriction on applications of <span style="font-family:courier;">F</span>.</p>
<p style="text-align:justify;">It is <i>guaranteed</i> that <span style="font-family:courier;">F</span> will have private ("unique") access to this particular argument (see Barendsen and Smetsers, 1993; Plasmeijer and Van Eekelen, 1993): the object will have a reference count of 1 <i>at the moment </i>it is inspected by the function. It is important to know that there can be more than 1 reference to the object before this specific access takes place. If a uniquely typed argument is not used to construct the function result it will become garbage (the reference has dropped to zero). Due to the fact that this analysis is performed statically the object can be garbage collected (<span style="color:blue;"><a href="CleanLanguageReport1.html#_1">see Chapter 1</a></span>) at compile-time. It is harmless to reuse the space occupied by the argument to create the function result. In other words: <i>it is allowed to update the unique object destructively without any consequences for referential transparency</i>.</p>
<p></p><div style="background-color:#FFFF45;">Example: the I/O library function <span style="font-family:courier;">fwritec</span>is used to write a character to a file yielding a new file as result. In general it is semantically not allowed to overwrite the argument file with the given character to construct the resulting file. However, by demanding the argument file to be unique by specifying </div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
fwritec::&nbsp;Char&nbsp;*File&nbsp;-&gt;&nbsp;*File<br></div>
<p></p><p style="text-align:justify;">It is guaranteed by the type system that <span style="font-family:courier;">fwritec</span> has private access to the file such that overwriting the file can be done without violating the functional semantics of the program. The resulting file is unique as well and can therefore be passed as continuation to another call of e.g. <span style="font-family:courier;">fwritec</span> to make further writing possible.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">WriteABC::&nbsp;*File&nbsp;-&gt;&nbsp;*File<br>
WriteABC&nbsp;file&nbsp;=&nbsp;fwritec&nbsp;'c'&nbsp;(fwritec&nbsp;'b'&nbsp;(fwritec&nbsp;'a'&nbsp;file))<br><p></p>
<p style="text-align:justify;">Observe that a unique file is passed in a single threaded way (as a kind of unique token) from one function to another where each function can safely modify the file knowing that is has private access to that file.</p>
<p></p><div style="background-color:#FFFF45;">One can make these intermediate files more vissible by by writing the <span style="font-family:courier;">WriteABC</span> as follows.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
WriteABC&nbsp;file&nbsp;=&nbsp;file3<br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;&nbsp;&nbsp;file1&nbsp;=&nbsp;fwritec&nbsp;'a'&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;file2&nbsp;=&nbsp;fwritec&nbsp;'b'&nbsp;file1<br>
&nbsp;&nbsp;&nbsp;&nbsp;file3&nbsp;=&nbsp;fwritec&nbsp;'c'&nbsp;file2<br>
<br></div>
<div style="background-color:#FFFF45;">or, alternatively (to avoid the explicit numbering of the files),</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
WriteABC&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;file&nbsp;=&nbsp;fwritec&nbsp;'a'&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;=&nbsp;fwritec&nbsp;'b'&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fwritec&nbsp;'c'&nbsp;file<br></div>
<p></p><p style="text-align:justify;">The type system makes it possible to make no distinction between a CLEAN file and a physical file of the real world: file I/O can be treated as efficiently as in imperative languages. The uniqueness typing prevents writing while other readers/writers are active. E.g. one cannot apply <span style="font-family:courier;">fwritec</span> to a file being used elsewhere.</p>
<p></p><div style="background-color:#FFFF45;">For instance, the following expression is <i>not</i> approved by the type system:</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
(file,&nbsp;fwritec&nbsp;'a'&nbsp;file)<br></div>
<p></p><p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Function arguments with no uniqueness attributes added to the classical type are considered as "non-unique": there are no reference requirements for these arguments. The function is only allowed to have <i>read access</i> (as usual in a functional language) even if in some of the function applications the actual argument appears to have reference count 1.</td></tr>
</table>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">freadc::&nbsp;File&nbsp;-&gt;&nbsp;(Char,&nbsp;File)<br><p style="text-align:justify;">The function <span style="font-family:courier;">freadc</span> can be applied to both a unique as well as non-unique file. This is fine since the function only wants read access on the file. The type indicates that the result is always a non-unique file. Such a file can be passed for further reading, but not for further writing.</p>
<p style="text-align:justify;">To indicate that functions don't change uniqueness properties of arguments, one can use <span style="font-family:courier;">attribute variables</span>.</p>
<p></p><div style="background-color:#FFFF45;">The simplest example is the identity functions that can be typed as follows:</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
id::&nbsp;u:a&nbsp;-&gt;&nbsp;u:a<br>
id&nbsp;x&nbsp;=&nbsp;x<br>
<br></div>
<div style="background-color:#FFFF45;">Here <span style="font-family:courier;">a</span> is an ordinary type variable, whereas <span style="font-family:courier;">u</span> is an attribute variable. If <span style="font-family:courier;">id</span> is applied to an unique object the result is also unique (in that case <span style="font-family:courier;">u</span> is instantiated with the concrete attribute <span style="font-family:courier;">*</span>). Of course, if id is applied to a non-unique object, the result remains non-unique. As with ordinary type variables, attribute variables should be instantiated uniformly.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"></div>
<p></p><p></p><div style="background-color:#FFFF45;">A more interesting example is the function <span style="font-family:courier;">freadc</span> that is typed as</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
freadc::&nbsp;u:File&nbsp;-&gt;&nbsp;u:(Char,&nbsp;u:File)<br>
<br></div>
<div style="background-color:#FFFF45;">Again <span style="font-family:courier;">freadc</span> can be applied to both unique and non-unique files. In the first case the resulting file is also unique and can, for example, be used for further reading or writing. Moreover, observe that not only the resulting file is attributed, but also the tuple containing that file and the character that has been read. This is due to the so called <i>uniqueness propagation rule</i>; see below.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"></div>
<p></p><p style="text-align:justify;">To summarize, uniqueness typing makes it possible to update objects destructively within a purely functional language. For the development of real world applications (which manipulate files, windows, arrays, databases, states etc.) this is an indispensable property.</p>
<h2 style="background-color:#9999FF;"><a id="_9.2">9.2 Attribute Propagation</a></h2>
<p style="text-align:justify;">Having explained the general ideas of uniqueness typing, we can now focus on some details of this typing system.</p>
<p style="text-align:justify;">If a unique object is stored in a data structure, the data structure itself becomes unique as well. This <i>uniqueness propagation rule</i> prevents that unique objects are shared indirectly via the data structure in which these objects are stored. To explain this form of hidden sharing, consider the following definition of the function head</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">head::&nbsp;[*a]&nbsp;-&gt;&nbsp;*a<br>
head&nbsp;[hd:tl]&nbsp;=&nbsp;hd<br><p></p>
<p style="text-align:justify;">The pattern causes head to have access to the "deeper" arguments <span style="font-family:courier;">hd</span> and <span style="font-family:courier;">tl</span>. Note that head does not have any uniqueness requirements on its direct list argument. This means that in an application of head the list might be shared, as can be seen in the following function heads</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">heads&nbsp;list&nbsp;=&nbsp;(head&nbsp;list,&nbsp;head&nbsp;list)<br><p></p>
<p style="text-align:justify;">If one wants to formulate uniqueness requirements on, for instance, the <span style="font-family:courier;">hd</span> argument of <span style="font-family:courier;">head</span>, it is <i>not</i> sufficient to attribute the corresponding type variable <span style="font-family:courier;">a</span> with <span style="font-family:courier;">*</span>; the surrounding list itself should also become unique. One can easily see that, without this additional requirement the <span style="font-family:courier;">heads</span> example with type</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">heads::&nbsp;[*a]&nbsp;-&gt;&nbsp;(*a,*a)<br>
heads&nbsp;list&nbsp;=&nbsp;(head&nbsp;list,&nbsp;head&nbsp;list)<br><p></p>
<p style="text-align:justify;">would still be valid although it delivers the same object twice. By demanding that the surrounding list becomes unique as well, (so the type of <span style="font-family:courier;">head</span> becomes <span style="font-family:courier;">head:: *[*a] -&gt; *a</span>) the function <span style="font-family:courier;">heads</span> is rejected. In general one could say that uniqueness <i>propagates outwards</i>.</p>
<p style="text-align:justify;">Some of the readers will have noticed that, by using attribute variables, one can assign a more general uniqueness type to head:</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">head::&nbsp;u:[u:a]&nbsp;-&gt;&nbsp;u:a<br><p></p>
<p style="text-align:justify;">The above propagation rule imposes additional (implicit) restrictions on the attributes appearing in type specifications of functions.</p>
<p style="text-align:justify;">Another explicit way of indicating restrictions on attributes is by using <i>coercion statements</i>. These statements consist of attribute variable inequalities of the form <span style="font-family:courier;">u &lt;= v</span>. The idea is that attribute substitutions are only allowed if the resulting attribute inequalities are valid, i.e. not resulting in an equality of the form</p>
<p style="text-align:justify;">'non-unique &le; unique'.</p>
<p style="text-align:justify;">The use of coercion statements is illustrated by the next example in which the uniqueness type of the well-known append function is shown.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">append::&nbsp;v:[u:a]&nbsp;w:[u:a]&nbsp;-&gt;&nbsp;x:[u:a],&nbsp;&nbsp;&nbsp;&nbsp;[v&lt;=u,&nbsp;w&lt;=u,&nbsp;x&lt;=u,w&lt;=x]<br><p></p>
<p style="text-align:justify;">The first three coercion statements express the uniqueness propagation for lists: if the elements <span style="font-family:courier;">a</span> are unique (by choosing <span style="font-family:courier;">*</span> for <span style="font-family:courier;">u</span>) these statements force <span style="font-family:courier;">v</span>,<span style="font-family:courier;">w</span> and <span style="font-family:courier;">x</span> to be instantiated with <span style="font-family:courier;">*</span> also. (Note that <span style="font-family:courier;">u &lt;= *</span><span style="font-family:courier;"> iff </span><span style="font-family:courier;">u = *</span>.) The statement <span style="font-family:courier;">w &lt;= x</span> expresses that the spine uniqueness of <span style="font-family:courier;">append</span>'s result depends only on the spine attribute <span style="font-family:courier;">w</span> of the second argument.</p>
<p style="text-align:justify;">In CLEAN it is permitted to omit attribute variables and attribute inequalities that arise from propagation properties; these will be added automatically by the type system. As a consequence, the following type for <span style="font-family:courier;">append</span> is also valid.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">append::&nbsp;[u:a]&nbsp;w:[u:a]&nbsp;-&gt;&nbsp;x:[u:a],&nbsp;&nbsp;&nbsp;&nbsp;[w&lt;=x]<br><p></p>
<p style="text-align:justify;">Of course, it is always allowed to specify a more specific type (by instantiating type or attribute variables). All types given below are valid types for <span style="font-family:courier;">append</span>.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">append::&nbsp;[u:a]&nbsp;x:[u:a]&nbsp;-&gt;&nbsp;x:[u:a],<br>
append::&nbsp;*[*Int]&nbsp;*[*Int]&nbsp;-&gt;&nbsp;*[*Int],<br>
append::&nbsp;[a]&nbsp;*[a]&nbsp;-&gt;&nbsp;*[a].<br><p></p>
<p style="text-align:justify;">To make types more readable, CLEAN offers the possibility to use <i>anonymous</i> attribute variables. These can be used as a shorthand for indicating attribute variables of which the actual names are not essential. This allows us to specify the type for <span style="font-family:courier;">append</span> as follows.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">append::&nbsp;[.a]&nbsp;w:[.a]&nbsp;-&gt;&nbsp;x:[.a],&nbsp;&nbsp;&nbsp;[w&lt;=x]<br><p></p>
<p style="text-align:justify;">The type system of CLEAN will substitute real attribute variables for the anonymous ones. Each dot gives rise to a new attribute variable except for the dots attached to type variables: type variables are attributed uniformly in the sense that all occurrences of the same type variable will obtain the same attribute. In the above example this means that all dots are replaced by one and the same new attribute variable.</p>
<h2 style="background-color:#9999FF;"><a id="_9.3">9.3 Defining New Types with Uniqueness Attributes</a></h2>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">AlgebraicTypeDef</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:9.05454545454545%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>::</b></span>TypeLhs</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:60.7939393939394%;padding:0 0 4px 0;" colspan="13"><span style="font-family:courier;color:#993300;"><b>=</b></span> ConstructorDef</td></tr>
<tr><td style="width:37.1858585858586%;padding:0 0 4px 0;" colspan="5"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:60.7939393939394%;padding:0 0 4px 0;" colspan="13">{<span style="font-family:courier;color:#993300;"><b>|</b></span> ConstructorDef} <span style="font-family:courier;color:#0000FF;"><b>;</b></span></td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">ConstructorDef</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8686868686869%;padding:0 0 4px 0;" colspan="15">[ExistQuantVariables] <span style="font-family:courier;">ConstructorName</span> {ArgType} {<span style="font-family:courier;color:#993300;"><b>&amp;</b></span> ClassConstraints}</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">|</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8686868686869%;padding:0 0 4px 0;" colspan="15">[ExistQuantVariables] <span style="font-family:courier;color:#993300;"><b>(</b></span><span style="font-family:courier;">ConstructorName</span><span style="font-family:courier;color:#993300;"><b>)</b></span> [FixPrec] {ArgType} {<span style="font-family:courier;color:#993300;"><b>&amp;</b></span> ClassConstraints}</td></tr>
</table><p></p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">TypeLhs</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">[<span style="font-family:courier;color:#993300;"><b>*</b></span>] TypeConstructor {[<span style="font-family:courier;color:#993300;"><b>*</b></span><span style="font-family:courier;">]TypeVariable</span>}</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">TypeConstructor</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;">TypeName</span></td></tr>
</table><p></p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">ExistQuantVariables</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>E.</b></span>{TypeVariable }+<span style="font-family:courier;color:#993300;"><b>:</b></span></td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">UnivQuantVariables</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>A.</b></span>{TypeVariable }+<span style="font-family:courier;color:#993300;"><b>:</b></span></td></tr>
</table><p></p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">BrackType</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">[Strict] [UnqTypeAttrib] SimpleType</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">ArgType</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">BrackType</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">|</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">[Strict] [UnqTypeAttrib] <span style="font-family:courier;color:#993300;"><b>(</b></span>UnivQuantVariables Type [ClassContext]<span style="font-family:courier;color:#993300;"><b>)</b></span></td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">UnqTypeAttrib</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>*</b></span></td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">|</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">UniqueTypeVariable<span style="font-family:courier;color:#993300;"><b>:</b></span></td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">|</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>.</b></span></td></tr>
</table><p></p>
<p style="text-align:justify;">As can be inferred from the syntax, the attributes that are actually allowed in data type definitions are '<span style="font-family:courier;">*</span>' and '<span style="font-family:courier;">.</span>'; attribute variables are not permitted. The (unique) <span style="font-family:courier;">*</span> attribute can be used at any subtype whereas the (anonymous). attribute is restricted to non-variable positions.</p>
<p style="text-align:justify;">If no uniqueness attributes are specified, this does not mean that one can only build non-unique instances of such a data type. Attributes not explicitly specified by the programmer are added automatically by the type system. To explain this standard uniqueness attribution mechanism, first remember that the types of data constructors are not specified by the programmer but derived from their corresponding data type definition.</p>
<p></p><div style="background-color:#FFFF45;">For example, the (classical) definition of the <span style="font-family:courier;">List</span> type</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
::&nbsp;List&nbsp;a&nbsp;=&nbsp;Cons&nbsp;a&nbsp;(List&nbsp;a)&nbsp;|&nbsp;Nil<br>
<br></div>
<div style="background-color:#FFFF45;">leads to the following types for its data constructors:</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Cons::&nbsp;a&nbsp;(List&nbsp;a)&nbsp;-&gt;&nbsp;List&nbsp;a<br>
Nil::&nbsp;List&nbsp;a<br></div>
<p></p><p style="text-align:justify;">To be able to create unique instances of data types, the standard attribution of CLEAN will automatically derive appropriate uniqueness variants for the types of the corresponding data constructors. Such a uniqueness variant is obtained via a consistent attribution of all types and subtypes appearing in a data type definition. Here, consistency means that such an attribution obeys the following rules (assume that we have a type definition for some type <span style="font-family:courier;">T</span>).</p>
<table style="width:100%;"><tr><td>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">1)</td><td style="text-align:justify;">Attributes that are explicitly specified are adopted.</td></tr></table>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">2)</td><td style="text-align:justify;">Each (unattributed) type variable and each occurrence of <span style="font-family:courier;">T</span> will receive an attribute variable. This is done in a uniform way: equal type variables will receive equal attributes, and all occurrence of <span style="font-family:courier;">T</span> are also equally attributed.</td></tr></table>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">3)</td><td style="text-align:justify;">Attribute variables are added at non-variable positions if they are required by the propagation properties of the corresponding type constructor. The attribute variable that is chosen depends on the argument types of this constructor: the attribution scheme takes the attribute variable of first argument appearing on a propagating position (see example below).</td></tr></table>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">4)</td><td style="text-align:justify;">All occurrences of the <span style="font-family:courier;">.</span>attribute are replaced by the attribute variable assigned to the occurrences of <span style="font-family:courier;">T</span>.</td></tr></table>
</td></tr></table>
<p></p><div style="background-color:#FFFF45;">Example of standard attribution for data constructors. For <span style="font-family:courier;">Cons</span> the standard attribution leads to the type</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Cons::&nbsp;u:a&nbsp;v:(List&nbsp;u:a)&nbsp;-&gt;&nbsp;v:List&nbsp;u:a,&nbsp;[v&lt;=u]<br>
<br></div>
<div style="background-color:#FFFF45;">The type of <span style="font-family:courier;">Nil</span> becomes</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Nil::&nbsp;v:List&nbsp;u:a,&nbsp;[v&lt;=u]<br></div>
<p></p><p></p><div style="background-color:#FFFF45;">Consider the following <span style="font-family:courier;">Tree</span> definition</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
::&nbsp;Tree&nbsp;a&nbsp;&nbsp;=&nbsp;&nbsp;Node&nbsp;a&nbsp;[Tree&nbsp;a]<br>
<br></div>
<div style="background-color:#FFFF45;">The type of the data constructor <span style="font-family:courier;">Node</span> is</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Node::&nbsp;u:a&nbsp;v:[v:Tree&nbsp;u:a]&nbsp;-&gt;&nbsp;v:Tree&nbsp;u:a,&nbsp;[v&lt;=u]<br></div>
<p></p><p></p><div style="background-color:#FFFF45;">Another <span style="font-family:courier;">Tree</span> variant.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
::&nbsp;*Tree&nbsp;*a&nbsp;&nbsp;=&nbsp;&nbsp;Node&nbsp;a&nbsp;*[Tree&nbsp;a]<br>
<br></div>
<div style="background-color:#FFFF45;">leading to</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Node::&nbsp;*a&nbsp;*[*Tree&nbsp;*a]&nbsp;-&gt;&nbsp;*Tree&nbsp;*a<br>
<br></div>
<div style="background-color:#FFFF45;">Note that, due to propagation, all subtypes have become unique.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"></div>
<p></p><p style="text-align:justify;">Next, we will formalize the notion of uniqueness propagation. We say that an argument of a type constructor, say <span style="font-family:courier;">T</span>, is propagating if the corresponding type variable appears on a propagating position in one of the types used in the right-hand side of <span style="font-family:courier;">T</span>'s definition. A propagating position is characterized by the fact that it is not surrounded by an arrow type or by a type constructor with non-propagating arguments. Observe that the definition of propagation is cyclic: a general way to solve this problem is via a fixed-point construction.</p>
<p></p><div style="background-color:#FFFF45;">Example of the propagation rule. Consider the (record) type definition for <span style="font-family:courier;">Object</span>.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Object&nbsp;a&nbsp;b::&nbsp;&nbsp;{state::&nbsp;a,&nbsp;fun::&nbsp;b&nbsp;-&gt;&nbsp;a}<br>
<br></div>
<div style="background-color:#FFFF45;">The argument <span style="font-family:courier;">a</span> is propagating. Since <span style="font-family:courier;">b</span> does not appear on a propagating position inside this definition, <span style="font-family:courier;">Object</span> is not propagating in its second argument.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"></div>
<p></p><h2 style="background-color:#9999FF;"><a id="_9.4">9.4 Uniqueness and Sharing</a></h2>
<p style="text-align:justify;">The type inference system of CLEAN will derive uniqueness information <i>after</i> the classical Milner/Mycroft types of functions have been inferred (<span style="color:blue;"><a href="CleanLanguageReport4.html#_4.3">see 4.3</a></span>). As explained in <span style="color:blue;"><a href="#_9.1">Section 9.1</a></span>, a function may require a <i>non-unique</i> object, a <i>unique</i> object or a <i>possibly unique</i> object. Uniqueness of the result of a function will depend on the attributes of its arguments and how the result is constructed. Until now, we distinguished objects with reference count 1 from objects with a larger reference count: only the former might be unique (depending on the uniqueness type of the object itself). In practice, however, one can be more liberal if one takes the evaluation order into account. The idea is that multiple reference to an (unique) object are harmless if one knows that only one of the references will be present at the moment it is accessed destructively. This has been used in the following function.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">AppendAorB::&nbsp;*File&nbsp;-&gt;&nbsp;*File<br>
AppendAorB&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isEven&nbsp;position&nbsp;=&nbsp;fwritec&nbsp;'a'&nbsp;file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;fwritec&nbsp;'b'&nbsp;file<br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;&nbsp;&nbsp;position&nbsp;=&nbsp;sfposition&nbsp;file<br><p></p>
<p style="text-align:justify;">When the right-hand side of <span style="font-family:courier;">AppendAorB</span> is evaluated, the guard is determined first (so access from <span style="font-family:courier;">sfposition</span> to <span style="font-family:courier;">file</span> is not unique), and subsequently one of the alternatives is chosen and evaluated. Depending on <span style="font-family:courier;">position</span>, either the reference from the first <span style="font-family:courier;">fwritec</span> application to <span style="font-family:courier;">file</span> or that of the second application is left and therefore unique.</p>
<p style="text-align:justify;">For this reason, the uniqueness type system uses a kind of <i>sharing analysis</i>.  This sharing analysis is input for the uniqueness type system itself to check uniqueness type consistency (<span style="color:blue;"><a href="#_9.3">see 9.3</a></span>). The analysis will label each <i>reference</i> in the right-hand side of a function definition as <i>read-only</i> (if destructive access might be dangerous) or <i>write-permitted</i> (otherwise). Objects  accessed via a read-only reference are always non-unique. On the other hand, uniqueness of objects accessed via a reference labeled with <i>write-permitted</i> solely depends on the types of the objects themselves.</p>
<p style="text-align:justify;">Before describing the labeling mechanism of CLEAN we mention that the "lifetime" of references is determined on a syntactical basis. For this reason we classify references to the same expression in a function definition (say for <span style="font-family:courier;">f</span>) according to their estimated run-time use, as <i>alternative</i>, <i>observing</i> and <i>parallel</i>.</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Two references are <i>alternative</i> if they belong to different alternatives of <span style="font-family:courier;">f</span>. Note that alternatives are distinguished by patterns (including <span style="font-family:courier;">case</span> expressions) or by guards.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">A reference <span style="font-family:courier;">r</span> is <i>observing</i> w.r.t. a reference <span style="font-family:courier;">r'</span> if the expression containing <span style="font-family:courier;">r'</span> is either (1) guarded by an expression or (2) preceded by a strict let before expression containing <span style="font-family:courier;">r</span>.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Otherwise, references are in <i>parallel</i>.</td></tr></table>
<p style="text-align:justify;">The rules used by the sharing analysis to label each reference are the following.</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">A reference, say <span style="font-family:courier;">r</span>, to a certain object is labeled with read-only if there exist another reference, say <span style="font-family:courier;">r'</span>, to the same object such that either <span style="font-family:courier;">r</span> is observing w.r.t <span style="font-family:courier;">r'</span> or <span style="font-family:courier;">r</span> and <span style="font-family:courier;">r'</span>are in parallel.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Multiple references to <i>cyclic structures</i> are always labeled as read-only.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">All other references are labeled with write-permitted.</td></tr></table>
<p style="text-align:justify;">Unfortunately, there is still a subtlety that has to be dealt with. Observing references belonging in a strict context do not always vanish totally after the expression containing the reference has been evaluated: further analysis appears to be necessary to ensure their disappearance. More concretely, suppose <span style="font-family:courier;">e[r]</span> denotes the expression containing <span style="font-family:courier;">r</span>. If the type of <span style="font-family:courier;">e[r]</span> is a basic type then, after evaluation, <span style="font-family:courier;">e[r]</span> will be reference-free. In particular, it does not contain the reference <span style="font-family:courier;">r</span> anymore. However, If the type of <span style="font-family:courier;">e[r]</span> is not a basic type it is assumed that, after evaluation, <span style="font-family:courier;">e[r]</span> might still refer to r. But even in the latter case a further refinement is possible. The idea is, depending on <span style="font-family:courier;">e[r]</span>, to correct the type of the object to which <span style="font-family:courier;">r</span> refers partially in such way that only the parts of this object that are still shared lose their uniqueness.</p>
<p></p><div style="background-color:#FFFF45;">Consider, for example, the following rule</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
f&nbsp;l&nbsp;=<br>
<span style="font-family:courier;color:#FF0000;"><b>#!</b></span>&nbsp;x&nbsp;=&nbsp;hd&nbsp;(hd&nbsp;l)<br>
=&nbsp;(x,&nbsp;l)<br>
<br></div>
<div style="background-color:#FFFF45;">Clearly, x and l share a common substructure; <span style="font-family:courier;">x</span> is even part of <span style="font-family:courier;">l</span>. But the whole "spine" of <span style="font-family:courier;">l</span> (of type <span style="font-family:courier;">[[...]]</span>) does not contain any new external references. Thus, if <span style="font-family:courier;">l</span> was spine-unique originally, it remains spine unique in the result of <span style="font-family:courier;">f</span>. Apparently, the access to <span style="font-family:courier;">l</span> only affected part of <span style="font-family:courier;">l</span>'s structure. More technically, the type of <span style="font-family:courier;">l</span> itself is corrected to take the partial access on <span style="font-family:courier;">l</span> into account. In the previous example, <span style="font-family:courier;">x</span>, regarded as a function on <span style="font-family:courier;">l</span> has type <span style="font-family:courier;">[[a]] -&gt; a</span>. In <span style="font-family:courier;">f</span>'s definition the part of <span style="font-family:courier;">l</span>'s type corresponding to the variable a is made non-unique. This is clearly reflected in the derived type for <span style="font-family:courier;">f</span>, being </div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
f::&nbsp;u:[w:[a]]&nbsp;-&gt;&nbsp;(a,v:[x:[a]]),&nbsp;[w&nbsp;&lt;=&nbsp;x,&nbsp;u&nbsp;&lt;=&nbsp;v]<br></div>
<p></p><p style="text-align:justify;">In CLEAN this principle has been generalized: If the strict let expression <span style="font-family:courier;">e[r]</span> regarded as a function on r has type</p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">T&nbsp;(...&nbsp;a...)&nbsp;-&gt;&nbsp;a<br><p style="text-align:justify;">Then the a-part of the type of the object to which r refers becomes non-unique; the rest of the type remains unaffected. If the type of <span style="font-family:courier;">e[r]</span> is not of the indicated form, <span style="font-family:courier;">r</span> is not considered as an observing reference (w.r.t. some reference <span style="font-family:courier;">r'</span>), but, instead, as in parallel with <span style="font-family:courier;">r'</span>.</p>
<h3 style="background-color:#9999FF;"><a id="_9.4.1">9.4.1 Higher Order Uniqueness Typing</a></h3>
<p style="text-align:justify;">Higher-order functions give rise to partial (often called <i>curried</i>) applications, i.e. applications in which the actual number of arguments is less than the arity of the corresponding symbol. If these partial applications contain unique sub-expressions one has to be careful.</p>
<p></p><div style="background-color:#FFFF45;">Consider, for example the following the function <span style="font-family:courier;">fwritec</span> with type</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
fwritec::&nbsp;*File&nbsp;Char&nbsp;-&gt;&nbsp;*File<br>
<br></div>
<div style="background-color:#FFFF45;">in the application</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
fwritec&nbsp;unifile<br>
<br></div>
<div style="background-color:#FFFF45;">(assuming that unifile returns a unique file). Clearly, the type of this application is of the form <span style="font-family:courier;">o:(Char -&gt; *File)</span>. The question is: what kind of attribute is <span style="font-family:courier;">o</span>? Is it a variable, is it *, or, is it not unique? Before making a decision, one should notice that it is dangerous to allow the above application to be shared. For example, if the expression <span style="font-family:courier;">fwritec unifile</span> is passed to a function</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
WriteAB&nbsp;write_fun&nbsp;=&nbsp;(write_fun&nbsp;'a',&nbsp;write_fun&nbsp;'b')<br></div>
<p></p><p style="text-align:justify;">Then the argument of <span style="font-family:courier;">fwritec</span> is no longer unique at the moment one of the two write operations take place. Apparently, the <span style="font-family:courier;">fwritec unifile</span> expression is <i>essentially</i> unique: its reference count should never become greater than 1. To prevent such an essentially unique expression from being copied, CLEAN considers the <span style="font-family:courier;">-&gt;</span> type constructor in combination with the <span style="font-family:courier;">*</span> attribute as special: it is not permitted to discard its uniqueness. Now, the question about the attribute <span style="font-family:courier;">o</span> can be answered: it is set to <span style="font-family:courier;">*</span>. If <span style="font-family:courier;">WriteAB</span> is typed as follows</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">WriteAB::&nbsp;(Char&nbsp;-&gt;&nbsp;u:File)&nbsp;-&gt;&nbsp;(u:File,&nbsp;u:File)<br>
WriteAB&nbsp;write_fun&nbsp;=&nbsp;(write_fun&nbsp;'a',&nbsp;write_fun&nbsp;'b')<br><p></p>
<p style="text-align:justify;">the expression <span style="font-family:courier;">WriteAB (fwritec unifile)</span> is rejected by the type system because it does not allow the argument of type <span style="font-family:courier;">*(Char -&gt; *File)</span> to be coerced to <span style="font-family:courier;">(Char -&gt; u:File)</span>. One can easily see that it is impossible to type <span style="font-family:courier;">WriteAB</span> in such a way that the expression becomes typable.</p>
<p style="text-align:justify;">To define data structures containing Curried applications it is often convenient to use the (anonymous) <span style="font-family:courier;">.</span> attribute. Example</p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">::&nbsp;Object&nbsp;a&nbsp;b&nbsp;=&nbsp;{&nbsp;state::&nbsp;a,&nbsp;fun::.(b&nbsp;-&gt;&nbsp;a)&nbsp;}<br>
new::&nbsp;*&nbsp;Object&nbsp;*File&nbsp;Char<br>
new&nbsp;=&nbsp;{&nbsp;state&nbsp;=&nbsp;unifile,&nbsp;fun&nbsp;=&nbsp;fwritec&nbsp;unifile&nbsp;}<br><p style="text-align:justify;">By adding an attribute variable to the function type in the definition of <span style="font-family:courier;">Object</span>, it is possible to store unique functions in this data structure. This is shown by the function <span style="font-family:courier;">new</span> . Since <span style="font-family:courier;">new</span> contains an essentially unique expression it becomes essentially unique itself. So, <span style="font-family:courier;">new</span> can never lose its uniqueness, and hence, it can only be used in a context in which a unique object is demanded.</p>
<p style="text-align:justify;">Determining the type of a curried application of a function (or data constructor) is somewhat more involved if the type of that function contains attribute variables instead of concrete attributes. Mostly, these variables will result in additional coercion statements. as can be seen in the example below.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">Prepend::&nbsp;u:[.a]&nbsp;[.a]&nbsp;-&gt;&nbsp;v:[.a],&nbsp;&nbsp;[u&lt;=v]<br>
Prepend&nbsp;a&nbsp;b&nbsp;=&nbsp;Append&nbsp;b&nbsp;a<br>
<br>
PrependList::&nbsp;u:[.a]&nbsp;-&gt;&nbsp;w:([.a]&nbsp;-&gt;&nbsp;v:[.a]),&nbsp;&nbsp;&nbsp;&nbsp;[u&lt;=v,&nbsp;w&lt;=u]<br>
PrependList&nbsp;a&nbsp;=&nbsp;Prepend&nbsp;a<br><p></p>
<p style="text-align:justify;">Some explanation is in place. The expression <span style="font-family:courier;">(PrependList some_list)</span> yields a function that, when applied to another list, say <span style="font-family:courier;">other_list</span>, delivers a new list extended consisting of the concatenation of <span style="font-family:courier;">other_list</span> and <span style="font-family:courier;">some_list</span>. Let's call this final result new_list. If <span style="font-family:courier;">new_list</span> should be unique (i.e. v becomes <span style="font-family:courier;">*</span>) then, because of the coercion statement <span style="font-family:courier;">u&lt;=v</span> the attribute u also becomes <span style="font-family:courier;">*</span>. But, if <span style="font-family:courier;">u = *</span> then also <span style="font-family:courier;">w = *</span>, for, <span style="font-family:courier;">w&lt;=u</span>. This implies that (arrow) type of the original expression <span style="font-family:courier;">(PrependList some_list)</span> becomes unique, and hence this expression cannot be shared.</p>
<h3 style="background-color:#9999FF;"><a id="_9.4.2">9.4.2 Uniqueness Type Coercions</a></h3>
<p style="text-align:justify;">As said before, offering a unique object to a function that requires a non-unique argument is safe (unless we are dealing with unique arrow types; see above). The technical tool to express this is via a coercion (subtype) relation based on the ordering</p>
<p style="text-align:justify;">'unique' &le; 'non-unique'</p>
<p style="text-align:justify;">on attributes. Roughly, the validity of &sigma; &le; &sigma;' depends subtype-wise on the validity of <span style="font-family:courier;">u</span> &le; <span style="font-family:courier;">u'</span> with <span style="font-family:courier;">u</span>,<span style="font-family:courier;">u'</span> attributes in &sigma;,&sigma;`. One has, for example</p>
<p style="text-align:justify;"><span style="font-family:courier;">u:[v:[w:Int]]</span> &le; <span style="font-family:courier;">u':[v':[w':Int]]</span> iff <span style="font-family:courier;">u</span> &le; <span style="font-family:courier;">u'</span>, <span style="font-family:courier;">v</span> &le; <span style="font-family:courier;">v'</span>, <span style="font-family:courier;">w</span> &le; <span style="font-family:courier;">w'</span>.</p>
<p style="text-align:justify;">However, a few refinements are necessary. Firstly, the uniqueness constraints expressed in terms of coercion statements (on attribute variables) have to be taken into account. Secondly, the coercion restriction on arrow types should be handled correctly. And thirdly, due to the so-called <i>contravariance</i> of <span style="font-family:courier;">-&gt;</span> in its first argument we have that</p>
<p style="text-align:justify;"><span style="font-family:courier;">u</span>:(&sigma; <span style="font-family:courier;">-&gt;</span> &sigma;') &le; <span style="font-family:courier;">u</span>:(&tau; <span style="font-family:courier;">-&gt;</span> &tau;') iff &tau; &le; &sigma;, &sigma;' &le; &tau;'</p>
<p style="text-align:justify;">Since <span style="font-family:courier;">-&gt;</span> may appear in the definitions of algebraic type constructors, these constructors may inherit the co- and contravariant subtyping behavior with respect to their arguments. We can classify the 'sign' of the arguments of each type constructor as + (positive, covariant), - (negative, contravariant) or top (both positive and negative). In general this is done by analysing the (possible mutually recursive) algebraic type definitions by a fixed-point construction, with basis sign(<span style="font-family:courier;">-&gt;</span>) = (<span style="font-family:courier;">-</span>,<span style="font-family:courier;">+</span>).</p>
<p></p><div style="background-color:#FFFF45;">Example: <span style="font-family:courier;">a</span> has sign <span style="font-family:courier;">T</span>, <span style="font-family:courier;">b</span> has sign <span style="font-family:courier;">+</span> in</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
::FunList&nbsp;a&nbsp;b&nbsp;=&nbsp;FunCons&nbsp;(a,&nbsp;a&nbsp;-&gt;&nbsp;b)&nbsp;(FunList&nbsp;a&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;FunNil<br></div>
<p></p><p style="text-align:justify;">This leads to the following coercion rules</p>
<table style="width:100%;"><tr><td>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">5)</td><td style="text-align:justify;">Attributes of two corresponding type variables as well as of two corresponding arrow types must be equal.</td></tr></table>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">6)</td><td style="text-align:justify;">The sign classification of each type constructor is obeyed. If, for instance, the sign of &Tau;'s argument is negative, then &Tau; &sigma; &le; &Tau; &sigma;' iff &sigma;' &le; &sigma;</td></tr></table>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">7)</td><td style="text-align:justify;">In all other cases, the validity of a coercion relation depends on the validity of <span style="font-family:courier;">u</span> &le; <span style="font-family:courier;">u'</span>, where <span style="font-family:courier;">u</span>,<span style="font-family:courier;">u'</span> are attributes of the two corresponding subtypes.</td></tr></table>
</td></tr></table>
<p style="text-align:justify;">The presence of sharing inherently causes a (possibly unique) object to become non-unique, if it is accessed via a read-only reference. In CLEAN this is achieved by a type correction operation that converts each unique type S to its smallest non-unique supertype, simply by making the outermost attribute of S non-unique. Note that this operation fails if S is a function type.</p>
<h2 style="background-color:#9999FF;"><a id="_9.5">9.5 Combining Uniqueness Typing and Overloading</a></h2>
<p style="text-align:justify;">An overloaded function actually stands for a collection of real functions. The types of these real functions are obtained from the type of the overloaded function by substituting the corresponding instance type for the class variable. These instance types may contain uniqueness information, and, due to the propagation requirement, the above-mentioned substitution might give rise to uniqueness attributes overloaded type specification.</p>
<p style="text-align:justify;">Consider, for instance, the identity class</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;id&nbsp;a::&nbsp;a&nbsp;-&gt;&nbsp;a<br><p></p>
<p style="text-align:justify;">If we want to define an instance of <span style="font-family:courier;">id</span> for lists, say <span style="font-family:courier;">id L</span>, which leaves uniqueness of the list elements intact, the (fully expanded) type of <span style="font-family:courier;">idL</span> becomes</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>instance</b></span>&nbsp;id&nbsp;L&nbsp;v:[u:a]&nbsp;-&gt;&nbsp;v:[u:a]<br><p></p>
<p style="text-align:justify;">However, as said before, the type specification of such an instance is not specified completely: it is derived from the overloaded type in combination with the instance type (i.e. <span style="font-family:courier;">[...]</span> in this particular example).</p>
<p style="text-align:justify;">In CLEAN we require that the type specification of an overloaded operator anticipates on attributes arising from uniqueness propagation, that is, the uniqueness attribute of the class variable should be chosen in such a way that for any instance type this 'class attribute' does not conflict with the corresponding uniqueness attribute(s) in the fully expanded type of this instance. In the above example this means that the type of <span style="font-family:courier;">id</span> becomes</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;id&nbsp;a::&nbsp;a&nbsp;-&gt;&nbsp;a<br><p></p>
<p style="text-align:justify;">Another possibility is</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;id&nbsp;a::&nbsp;*a&nbsp;-&gt;&nbsp;*a<br><p></p>
<p style="text-align:justify;">However, the latter version of <span style="font-family:courier;">id</span> will be more restrictive in its use, since it will always require that its argument is unique.</p>
<h3 style="background-color:#9999FF;"><a id="_9.5.1">9.5.1 Constructor Classes</a></h3>
<p style="text-align:justify;">The combination of uniqueness typing and constructor classes (with their higher-order class variables) introduces another difficulty. Consider, for example, the overloaded map function.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;map&nbsp;m::&nbsp;(a&nbsp;-&gt;&nbsp;b)&nbsp;(m&nbsp;a)&nbsp;-&gt;&nbsp;m&nbsp;b<br><p></p>
<p style="text-align:justify;">Suppose we would add (distinct) attribute variables to the type variables <span style="font-family:courier;">a</span> and <span style="font-family:courier;">b</span> (to allow 'unique instances' of map)</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;map&nbsp;m::&nbsp;(.a&nbsp;-&gt;.b)&nbsp;(m&nbsp;.a)&nbsp;-&gt;&nbsp;m&nbsp;.b<br><p></p>
<p style="text-align:justify;">The question that arises is: Which attributes should be added to the two applications of the class variable <span style="font-family:courier;">m</span>? Clearly, this depends on the actual instance type filled in for <span style="font-family:courier;">m</span>. E.g., if <span style="font-family:courier;">m</span> is instantiated with a propagating type constructor (like <span style="font-family:courier;">[]</span>), the attributes of the applications of <span style="font-family:courier;">m</span> are either attribute variables or the concrete attribute 'unique'. Otherwise, one can choose anything.</p>
<p></p><div style="background-color:#FFFF45;">Example</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
<span style="font-family:courier;color:#FF0000;"><b>instance</b></span>&nbsp;map&nbsp;[]<br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;f&nbsp;l&nbsp;=&nbsp;[&nbsp;f&nbsp;x&nbsp;//&nbsp;x&nbsp;&lt;-&nbsp;l&nbsp;]<br>
<br>
::&nbsp;&nbsp;T&nbsp;a&nbsp;=&nbsp;C&nbsp;(Int&nbsp;-&gt;&nbsp;a)<br>
<br>
<span style="font-family:courier;color:#FF0000;"><b>instance</b></span>&nbsp;map&nbsp;T<br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;f&nbsp;(C&nbsp;g)&nbsp;=&nbsp;C&nbsp;(f&nbsp;o&nbsp;g)<br>
<br></div>
<div style="background-color:#FFFF45;">In this example, the respective expanded types of the instances are</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
map::&nbsp;(u:a&nbsp;-&gt;&nbsp;v:b)&nbsp;w:[u:a]&nbsp;-&gt;&nbsp;x:[v:b],&nbsp;[w&nbsp;&lt;=&nbsp;u,&nbsp;x&nbsp;&lt;=&nbsp;v]<br>
map::&nbsp;(u:a&nbsp;-&gt;&nbsp;v:b)&nbsp;(T&nbsp;u:a)&nbsp;-&gt;&nbsp;T&nbsp;v:b<br></div>
<p></p><p style="text-align:justify;">The type system of CLEAN requires that a possible propagation attribute is explicitly indicated in the type specification of the overloaded function. In order to obtain versions of <span style="font-family:courier;">map</span> producing spine unique data structures, its overloaded type should be specified as follows:</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;map&nbsp;m::&nbsp;(.a&nbsp;-&gt;.b).(m.&nbsp;a)&nbsp;-&gt;.(m.&nbsp;b)<br><p></p>
<p style="text-align:justify;">This type will provide that for an application like</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">map&nbsp;inc&nbsp;[1,2,3]<br><p></p>
<p style="text-align:justify;">indeed yields a spine unique list.</p>
<p style="text-align:justify;">Observe that if you would omit the (anonymous) attribute variable of the second argument, the input data structure cannot contain unique data on propagating positions, e.g. one could not use such a version of <span style="font-family:courier;">map</span> for mapping a destructive write operator on a list of unique files.</p>
<p style="text-align:justify;">In fact, the propagation rule is used to translate uniqueness properties of objects into uniqueness properties of the data structures in which these objects are stored. As said before, in some cases the actual data structures are unknown.</p>
<p style="text-align:justify;">Consider the following function</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">DoubleMap&nbsp;f&nbsp;l&nbsp;=&nbsp;(map&nbsp;f&nbsp;l,&nbsp;map&nbsp;f&nbsp;l)<br><p></p>
<p style="text-align:justify;">The type of this function is something like</p>
<p style="text-align:justify;">Clearly, <span style="font-family:courier;">l</span> is duplicated. However, this does not necessarily mean that a cannot be unique anymore. If, for instance, <span style="font-family:courier;">m</span> is instantiated with a non-propagating type constructor (like &Tau; as defined on the previous page) then uniqueness of a is still permitted. On the other hand, if <span style="font-family:courier;">m</span> is instantiated with a propagating type constructor, a unique instantiation of a should be disapproved. In CLEAN, the type system 'remembers' sharing of objects (like <span style="font-family:courier;">l</span> in the above example) by making the corresponding type attribute non-unique. Thus, the given type for <span style="font-family:courier;">DoubleMap</span> is exactly the type inferred by CLEAN's type system. If one tries to instantiate <span style="font-family:courier;">m</span> with a propagating type constructor, and, at the same type, a with some unique type, this will fail.</p>
<p style="text-align:justify;">The presence of higher-order class variables, not only influences propagation properties of types, but also the coercion relation between types. These type coercions depend on the sign classification of type constructors. The problem with higher-order polymorphism is that in some cases the actual type constructors substituted for the higher order type variables are unknown, and therefore one cannot decide whether coercions in which higher-order type variable are involved, are valid.</p>
<p style="text-align:justify;">Consider the functions</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">double&nbsp;x&nbsp;=&nbsp;(x,x)<br>
dm&nbsp;f&nbsp;l&nbsp;=&nbsp;double&nbsp;(map&nbsp;f&nbsp;l)<br><p></p>
<p style="text-align:justify;">Here, <span style="font-family:courier;">map</span>'s result (of type <span style="font-family:courier;">.(m .a)</span>) is coerced to the non-unique supertype <span style="font-family:courier;">(m .a)</span>. However, this is only allowed if <span style="font-family:courier;">m</span> is instantiated with type constructors that have no coercion restrictions. E.g., if one tries to substitute <span style="font-family:courier;">*WriteFun</span> for <span style="font-family:courier;">m</span>, where</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">WriteFun&nbsp;a&nbsp;=&nbsp;C.(a&nbsp;-&gt;&nbsp;*File)<br><p></p>
<p style="text-align:justify;">this should fail, for, <span style="font-family:courier;">*WriteFun</span> is <i>essentially</i> unique. The to solve this problem is to restrict coercion properties of type variable applications (m &sigma;) to</p>
<p style="text-align:justify;"><span style="font-family:courier;">u:</span>(<span style="font-family:courier;">m</span> &sigma;) = <span style="font-family:courier;">u:</span>(<span style="font-family:courier;">m</span> &tau;) iff &sigma; &le; &tau; &amp;&amp; &tau; &le; &sigma;</p>
<p style="text-align:justify;">A slightly modified version of this solution has been adopted in CLEAN. For convenience, we have added the following refinement. The instances of type constructors classes are restricted to type constructors with no coercion restrictions. Moreover, it is assumed that these type constructors are uniqueness propagating. This means that the <span style="font-family:courier;">WriteFun</span> cannot be used as an instance for <span style="font-family:courier;">map</span>. Consequently, our coercion relation we can be more liberal if it involves such class variable applications.</p>
<p style="text-align:justify;">Overruling this requirement can be done adding the anonymous attribute. the class variable. E.g.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;map.m::&nbsp;(.a&nbsp;-&gt;.b).(m.&nbsp;a)&nbsp;-&gt;.(m.&nbsp;b)<br><p></p>
<p style="text-align:justify;">Now</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>instance</b></span>&nbsp;map&nbsp;WriteFun&nbsp;<br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;&nbsp;&nbsp;map...<br><p></p>
<p style="text-align:justify;">is valid, but the coercions in which (parts of) <span style="font-family:courier;">map</span>'s type are involved are now restricted as explained above. To see the difference between the two indicated variants of constructor variables, we slightly modify map's type.</p>
<p style="text-align:justify;">To see the difference between the two indicated variants of constructor variables, we slightly modify <span style="font-family:courier;">map</span>'s type.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;"><span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;map&nbsp;m::&nbsp;(.a&nbsp;-&gt;.b)&nbsp;*(m.&nbsp;a)&nbsp;-&gt;.(m.&nbsp;b)<br><p></p>
<p style="text-align:justify;">Without overruling the instance requirement for <span style="font-family:courier;">m</span> the type of <span style="font-family:courier;">dm</span> (<span style="font-family:courier;">dm</span> as given on the previous page) becomes.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">dm::&nbsp;(.a&nbsp;-&gt;.b)&nbsp;*(m.a)&nbsp;-&gt;.(m&nbsp;b,&nbsp;m&nbsp;b)<br><p></p>
<p style="text-align:justify;">Observe that the attribute of disappeared due to the fact that each type constructor substituted for <span style="font-family:courier;">m</span> is assumed to be propagating.</p>
<p style="text-align:justify;">If one explicitly indicates that there are no instance restriction for the class variable <span style="font-family:courier;">m</span> (by attributing <span style="font-family:courier;">m</span> with.), the function <span style="font-family:courier;">dm</span> becomes untypable.</p>
<h2 style="background-color:#9999FF;"><a id="_9.6">9.6 Higher-Order Type Definitions</a></h2>
<p style="text-align:justify;">We will describe the effect of uniqueness typing on type definitions containing higher-order type variables. At it turns out, this combination introduces a number of difficulties which would make a full description very complex. But even after skipping a lot of details we have to warn the reader that some of the remaining parts are still hard to understand.</p>
<p style="text-align:justify;">As mentioned earlier, two properties of newly defined type constructor concerning uniqueness typing are important, namely, propagation and sign classification. One can probably image that, when dealing with higher-order types the determination on these properties becomes more involved. Consider, for example, the following type definition.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">::&nbsp;&nbsp;T&nbsp;m&nbsp;a&nbsp;=&nbsp;C&nbsp;(m&nbsp;a)<br><p></p>
<p style="text-align:justify;">The question whether <span style="font-family:courier;">T</span> is propagating in its second argument cannot be decided by examining this definition only; it depends on the actual instantiation of the (higher-order) type variable <span style="font-family:courier;">m</span>. If <span style="font-family:courier;">m</span> is instantiated with a propagating type constructor, like <span style="font-family:courier;">[]</span>, then <span style="font-family:courier;">T</span> becomes propagating in its second argument as well. Actually, propagation is not only a property of type constructors, but also of types themselves, particularly of 'partial types' For example, the partial type [] is propagating in its (only) argument (Note that the number of arguments a partial type expects, directly follows from the kinds of the type constructors that have been used). The type <span style="font-family:courier;">T []</span> is also propagating in its argument, so is the type <span style="font-family:courier;">T ((,) Int)</span>).</p>
<p style="text-align:justify;">The analysis in CLEAN that determines propagation properties of (partial) types has been split into two phases. During the first phase, new type definitions are examined in order to determine the propagation dependencies between the arguments of each new type constructor. To explain the idea, we return to our previous example.</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">::&nbsp;&nbsp;T&nbsp;m&nbsp;a&nbsp;=&nbsp;C&nbsp;(m&nbsp;a)<br><p></p>
<p style="text-align:justify;">First observe that the propagation of the type variable <span style="font-family:courier;">m</span> is not interesting because <span style="font-family:courier;">m</span> does not stand for 'real data' (which is always of kind <span style="font-family:courier;">*</span>). We associate the propagation of <span style="font-family:courier;">m</span> in <span style="font-family:courier;">T</span> with the position(s) of the occurrence(s) of <span style="font-family:courier;">m</span>'s applications. So in general, <span style="font-family:courier;">T</span> is propagating in a higher-order variable <span style="font-family:courier;">m</span> if one of <span style="font-family:courier;">m</span>'s applications appears on a propagating position in the definition of T. Moreover, for each higher order type variable, we determine the propagation properties of all first order type variables in the following way: <span style="font-family:courier;">m</span> is propagating in <span style="font-family:courier;">a</span>, where <span style="font-family:courier;">m</span> and <span style="font-family:courier;">a</span> are higher-order respectively first-order type variables of <span style="font-family:courier;">T</span>, if <span style="font-family:courier;">a</span> appears on a propagating position in one of <span style="font-family:courier;">m</span>'s applications. In the above example, <span style="font-family:courier;">m</span> is propagating in <span style="font-family:courier;">a</span>, since <span style="font-family:courier;">a</span> is on a propagating position in the application <span style="font-family:courier;">(m</span> <span style="font-family:courier;">a)</span>. During the second phase, the propagation properties of (partial) types are determined using the results of the first phase. This (roughly) proceeds as follows. Consider the type <span style="font-family:courier;">T</span> &sigma; for some (partial) type &sigma;, and <span style="font-family:courier;">T</span> as defined earlier. First, determine (recursively) the propagation of &sigma;. Then the type <span style="font-family:courier;">T</span> &sigma; is propagating if (1) &sigma; is propagating, (2) <span style="font-family:courier;">T</span> is propagating in <span style="font-family:courier;">m</span>, and moreover (3) <span style="font-family:courier;">m</span> is propagating in <span style="font-family:courier;">a</span> (the second argument of the type constructor). With <span style="font-family:courier;">T</span> as defined above, (2) and (3) are fulfilled. Thus, for example <span style="font-family:courier;">T</span> <span style="font-family:courier;">[]</span> is propagating and therefore also <span style="font-family:courier;">T</span> <span style="font-family:courier;">(T</span> <span style="font-family:courier;">[])</span>. Now define</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">::&nbsp;&nbsp;T2&nbsp;a&nbsp;=&nbsp;C2&nbsp;(a&nbsp;-&gt;&nbsp;Int)<br><p></p>
<p style="text-align:justify;">Then <span style="font-family:courier;">T</span> <span style="font-family:courier;">T2</span> is not propagating.</p>
<p style="text-align:justify;">The adjusted uniqueness propagation rule (see also...) becomes:</p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Let &sigma;,&tau; be two uniqueness types. Suppose &sigma; has attribute <span style="font-family:courier;">u</span>. Then, if &tau; is propagating the application (&tau; &sigma;) should have an attribute <span style="font-family:courier;">v</span> such that <span style="font-family:courier;">v</span> &le; <span style="font-family:courier;">u</span>.</td></tr></table>
<p style="text-align:justify;">Some of the readers might have inferred that this propagation rule is a 'higher-order' generalization of the old 'first-order' propagation rule.</p>
<p style="text-align:justify;">As to the sign classification, we restrict ourselves to the remark that that sign analysis used in CLEAN is adjusted in a similar way as described above for the propagation case.</p>
<p style="text-align:justify;">Example</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">::&nbsp;&nbsp;T&nbsp;m&nbsp;a&nbsp;=&nbsp;C&nbsp;((m&nbsp;a)&nbsp;-&gt;&nbsp;Int)<br><p></p>
<p style="text-align:justify;">The sign classification of <span style="font-family:courier;">T</span> if (-,<span style="font-family:courier;">&#x27c2;</span>). Here <span style="font-family:courier;">&#x27c2;</span> denotes the fact the <span style="font-family:courier;">a</span> is neither directly used on a positive nor on a negative position. The sign classification of m w.r.t. <span style="font-family:courier;">a</span> is +. The partial type <span style="font-family:courier;">T</span> <span style="font-family:courier;">[]</span> has sign -, which e.g. implies that</p>
<p style="text-align:justify;"><span style="font-family:courier;">T [] Int &le; T [] *Int</span></p>
<p style="text-align:justify;">The type <span style="font-family:courier;">T T2</span> (with <span style="font-family:courier;">T2</span> as defined on the previous page) has sign +, so</p>
<p style="text-align:justify;"><span style="font-family:courier;">T T2 Int &ge; T T2 *Int</span></p>
<p style="text-align:justify;">It will be clear that combining uniqueness typing with higher-order types is far from trivial: the description given above is complex and moreover incomplete. However explaining all the details of this combination is far beyond the scope of the reference manual.</p>
<h2 style="background-color:#9999FF;"><a id="_9.7">9.7 Destructive Updates using Uniqueness Typing</a></h2>
<p style="text-align:justify;">So, it is <i>allowed</i> to update a uniquely typed function argument (<span style="font-family:courier;">*</span>) destructively when the argument does not reappear in the function result. The question is: when does the compiler indeed make use of this possibility.</p>
<p style="text-align:justify;">Destructive updates takes place in some predefined functions and operators which work on predefined data structures such arrays (&amp;-operator) and files (writing to a file). Arrays and files are intended to be updated destructively and their use can have a big influence on the space and time behavior of your application (a new node does not have to be claimed and filled, the garbage collector is invoked less often and the locality of memory references is increased).</p>
<p style="text-align:justify;">Performing destructive updates is only sensible when information is stored in nodes. Arguments of basic type (<span style="font-family:courier;">Int</span>, <span style="font-family:courier;">Real</span>, <span style="font-family:courier;">Char</span> or <span style="font-family:courier;">Bool</span>) are stored on the B-stack or in registers and it therefore does not make sense to make them unique.</p>
<p style="text-align:justify;">The CLEAN compiler also has an option to re-use user-defined unique data structures: the space being occupied by a function argument of unique type will under certain conditions be reused destructively to construct the function result when (part of) this result is of the same type. So, a more space and time efficient program can be obtained by turning heavily used data structures into unique data structures. This is not just a matter of changing the uniqueness type attributes (like turning a lazy data structure into a strict one). A unique data structure also has to be used in a 'single threaded' way (see Chapter 4). This means that one might have to restructure parts of the program to maintain the unicity of objects.</p>
<p style="text-align:justify;">The compiler will do compile-time garbage collection for user defined unique data-structures only in certain cases. In that case run-time garbage collection time is reduced. It might even drop to zero. It is also possible that you gain even more than just garbage collection time due to better cache behavior.</p>
</body>
</html>
