<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Clean Language Report</title>
</head>
<body style="font-family:Helvetica">
<div><div style="position: absolute;"><svg width="355.555555555556" height="177.777777777778">
<path d="M49.7777777777778 7.32929319639176 h280.888888888889 v141.785858051661 h-280.888888888889 Z M64 33.9959598630584 h252.444444444444 v88.4525247183276 h-252.444444444444 Z" stroke="none" fill="#3F87AF" fill-rule="evenodd"/>
<path d="M64 111.781817914719 h252.444444444444 v10.6666666666667 h-252.444444444444 Z" stroke="none" fill="#8C96A0"/>
<path d="M64 33.9959598630584 h252.444444444444 v10.6666666666667 h-252.444444444444 Z" stroke="none" fill="#8C96A0"/>
<path d="M64 44.6626265297251 h252.444444444444 v67.1191913849942 h-252.444444444444 Z" stroke="none" fill="#FFFFFF"/>
<path d="M99.1179703874409 137.550135143052 C93.2711853763986 133.302197180425,88.084448516421 128.213312506961,83.725936053644 122.448484581386 L110.089961763567 122.448484581386 Z" stroke="none" fill="#8C96A0"/>
<path d="M99.1179703874409 18.8943093013927 C93.2711853763986 23.1422472640192,88.084448516421 28.2311319374834,83.725936053644 33.9959598630584 L110.089961763567 33.9959598630584 Z" stroke="none" fill="#8C96A0"/>
<path d="M126.968649704419 100.555210486665 C109.380820468897 87.7769045717629,109.380820468897 61.5564287615705,126.968649704419 48.7781228466684 L116.780371998016 34.7551616108359 C89.6658019265873 54.45504989631,89.6658019265873 94.8782834370233,116.780371998016 114.578171722497 Z" stroke="none" fill="#8C96A0"/>
<path d="M113.645517319123 118.89292902583 C83.5996423751073 97.0633230878727,83.5996423751073 52.2700102454607,113.645517319123 30.4404043075029 L102.673525942996 15.3387537458372 C62.3680839449271 44.6223714674879,62.3680839449271 104.710961865845,102.673525942996 133.994579587496 Z" stroke="none" fill="#8C96A0"/>
<path d="M123.413094148863 104.110766042221 C105.825264913342 91.3324601273184,105.825264913342 65.111984317126,123.413094148863 52.3336784022239 L113.22481644246 38.3107171663915 C86.1102463710318 58.0106054518656,86.1102463710318 98.4338389925788,113.22481644246 118.133727278053  Z" stroke="none" fill="#3F87AF"/>
<path d="M110.089961763567 122.448484581386 C80.0440868195518 100.618878643428,80.0440868195518 55.8255658010162,110.089961763567 33.9959598630584L83.725936053644 33.9959598630584 C63.9432065006372 60.1617750913602,63.9432065006372 96.2826693530842,83.725936053644 122.448484581386" stroke="none" fill="#3F87AF"/>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="145.777777777778" y="103.111111111111" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="144.888888888889" y="102.222222222222" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="144" y="101.333333333333" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="143.111111111111" y="100.444444444444" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="142.222222222222" y="99.5555555555556" fill="#3F87AF">Clean</text>
</svg>
</div><h1 style="text-align:right;background-color:#9999FF;"><a id="_10"><br>Chapter 10<br><br>Strictness, Macros and Efficiency</a></h1></div>
<p style="text-align:justify;">Programming in a functional language means that one should focus on algorithms and without worrying about all kinds of efficiency details. However, when large applications are being written it may happen that this attitude results in a program that is unacceptably inefficient in time and/or space.</p>
<p style="text-align:justify;">In this Chapter we explain several kinds of annotations and directives that can be defined in CLEAN. These annotations and directives are designed to give the programmer some means to influence the time and space behavior of CLEAN applications.</p>
<p style="text-align:justify;">CLEAN is by default a <i>lazy</i> language: applications will only be evaluated when their results are needed for the final outcome of the program. However, lazy evaluation is in general not very efficient. It is much more efficient to compute function arguments in advance (<i>strict</i> evaluation) when it is known that the arguments will be used in the function body. By using strictness annotations in type definitions the evaluation order of data structures and functions can be changed from lazy to strict. This is explained in <span style="color:blue;"><a href="#_10.1">Section 10.1</a></span>.</p>
<p style="text-align:justify;">One can define constant graphs on the global level also known as <span style="font-family:courier;">Constant Applicative Forms</span> (<span style="color:blue;"><a href="#_10.2">see Section 10.2</a></span>). Unlike constant functions, these constant graphs are shared such that they are computed only one. This generally reduces execution time possibly at the cost of some heap space needed to remember the shared graph constants.</p>
<p style="text-align:justify;">Macro's (<span style="color:blue;"><a href="#_10.3">Section 10.3</a></span>) are special functions that will already be substituted (evaluated) at <i>compile-time</i>. This generally reduces execution time (the work has already been done by the compiler) but it will lead to an increase of object code.</p>
<h2 style="background-color:#9999FF;"><a id="_10.1">10.1 Annotations to Change Lazy Evaluation into Strict Evaluation</a></h2>
<p style="text-align:justify;">CLEAN uses by default a <i>lazy evaluation strategy</i>: a redex is only evaluated when it is needed to compute the final result. Some functional languages (e.g. ML, Harper <i>et al.</i>) use an <i>eager</i>  (<i>strict</i>) evaluation strategy and always evaluate all function arguments in advance.</p>
<h3 style="background-color:#9999FF;"><a id="_10.1.1">10.1.1 Advantages and Disadvantages of Lazy versus Strict Evaluation</a></h3>
<p style="text-align:justify;">Lazy evaluation has the following advantages (+) / disadvantages (-) over eager (strict) evaluation:</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">only those computations which contribute to the final result are computed (for some algorithms this is a clear advantage while it generally gives a greater expressive freedom);</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">one can work with infinite data structures (e.g. [1..])</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">it is unknown when a lazy expression will be computed (disadvantage for debugging, for controlling evaluation order);</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">strict evaluation is in general much more efficient, in particular for objects of basic types, non-recursive types and tuples and records which are composed of such types;</td></tr></table>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">+/-</td><td style="text-align:justify;">in general a strict expression (e.g. <span style="font-family:courier;">2</span> <span style="font-family:courier;">+</span> <span style="font-family:courier;">3</span> <span style="font-family:courier;">+</span> <span style="font-family:courier;">4</span>) takes less space than a lazy one, however, sometimes the other way around (e.g. <span style="font-family:courier;">[1..1000]</span>);</td></tr></table>
<h3 style="background-color:#9999FF;"><a id="_10.1.2">10.1.2 Strict and Lazy Context</a></h3>
<p style="text-align:justify;">Each expression in a function definition is considered to be either strict (appearing in a <i>strict context</i>: it has to be evaluated to strong root normal form) or lazy (appearing in a <i>lazy context</i> : not yet to be evaluated to strong root normal form)  The following rules specify whether or not a particular expression is lazy or strict:</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">a non-variable pattern is strict;</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">an expression in a guard is strict;</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">the expressions specified in a strict let-before expression are strict;</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">the <b>root expression</b> is strict;</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">the arguments of a function or data constructor in a strict context are strict when these arguments are being annotated as strict in the type definition of that function (manually or automatically) or in the type definition of the data constructor;</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">all the other expressions are lazy.</td></tr></table>
<p style="text-align:justify;">Evaluation of a function will happen in the following order: patterns, guard, expressions in a strict let before expression, root expression (<span style="color:blue;"><a href="CleanLanguageReport3.html#_3.1">see also 3.1</a></span>).</p>
<h3 style="background-color:#9999FF;"><a id="_10.1.3">10.1.3 Space Consumption in Strict and Lazy Context</a></h3>
<p style="text-align:justify;">The space occupied by CLEAN structures depend on the kind of structures one is using, but also depends on whether these data structures appear in a strict or in a lazy context. To understand this one has to have some knowledge about the basic implementation of CLEAN (see Plasmeijer and Van Eekelen, 1993).</p>
<p style="text-align:justify;">Graphs (<span style="color:blue;"><a href="CleanLanguageReport1.html#_1">see Chapter 1</a></span>) are stored in a piece of memory called the heap. The amount of heap space needed highly depends on the kind of data structures that are in use. Graph structures that are created in a lazy context can occupy more space than graphs created in a strict context. The garbage collector in the run-time system of CLEAN automatically collects graphs that are not being used. The arguments of functions being evaluated are stored on a stack. There are two stacks: the A-stack, which contains references to graph nodes stored in the heap and the BC-stack which contains arguments of basic type and return addresses. Data structures in a <i>lazy context</i> are passed via references on the A-stack. Data structures of the <i>basic types</i> (<span style="font-family:courier;">Int</span>, <span style="font-family:courier;">Real</span>, <span style="font-family:courier;">Char</span> or <span style="font-family:courier;">Bool</span>) in a <i>strict context</i> are stored on the B-stack or in registers. This is also the case for these strict basic types when they are part of a <i>record</i> or <i>tuple</i> in a strict context.</p>
<p style="text-align:justify;">Data structures living on the B-stack are passed <i>unboxed</i>. They consume less space (because they are not part of a node) and can be treated much more efficiently. When a function is called in a lazy context its data structures are passed in a graph node (<i>boxed</i>). The amount of space occupied is also depending on the arity of the function.</p>
<p style="text-align:justify;">In the table below the amount of space consumed in the different situations is summarised (for the lazy as well as for the strict context). For the size of the elements one can take the size consumed in a strict context.</p>
<p></p><table style="border-collapse:collapse;width:100%;background-color:#FFFF99;"><tr style="border-bottom:1px solid #969696"><td style="width:21.8181818181818%;"><i>Type</i></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><i>Arity</i></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><i>Lazy context (bytes)</i></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><i>Strict context (bytes)</i></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"><i>Comment</i></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Int,Bool</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">8</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Int (0&le;n&le;32), Char  </span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;">node is shared</td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Real</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">8</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Small Record</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4 + &Sigma; size elements</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">&Sigma; size elements</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;">total length&le;12</td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Large Record</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">8 + &Sigma; size elements</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">&Sigma; size elements</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Tuple</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">2</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">&Sigma; size elements</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">&gt;2</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">8  + 4*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">&Sigma; size elements</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">{a}</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">20 + 4*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12 + 4*n</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;"> !Int</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">20 + 4*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12 + 4*n</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;"> !Bool,!Char</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">20 + 4*ceil(n/4)</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12 + 4*ceil(n/4)</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;"> !Real</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">20 + 8*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12 + 8*n</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;"> !Tuple, !Record</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">20 + size rec/tup*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12 + size rec/tup*n</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Hnf</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">0</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4 + size node</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;">node is shared </td></tr>
<tr><td style="width:21.8181818181818%;"></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">1</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">8</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4 + size node</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">2</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4 + size node</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;">also for <span style="font-family:courier;">[a]</span></td></tr>
<tr><td style="width:21.8181818181818%;"></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">&gt;2</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">8  + 4*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4 + size node</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Pointer to node</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"><span style="font-family:courier;">Function</span></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">0,1,2</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">12</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
<tr><td style="width:21.8181818181818%;"></td><td style="border-left:1px solid #969696;width:5.45454545454545%;"><span style="font-family:courier;">&gt;2</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">4  + 4*n</span></td><td style="border-left:1px solid #969696;width:20.7272727272727%;"><span style="font-family:courier;">-</span></td><td style="border-left:1px solid #969696;width:12.4309090909091%;"></td></tr>
</table><p></p>
<h3 style="background-color:#9999FF;"><a id="_10.1.4">10.1.4 Time Consumption in Strict and Lazy Context</a></h3>
<p style="text-align:justify;">Strict arguments of functions can sometimes be handled much more efficiently than lazy arguments, in particular when the arguments are of basic type.</p>
<p></p><div style="background-color:#FFFF45;">Example: functions with strict arguments of basic type are more efficient.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Ackerman::&nbsp;!Int&nbsp;!Int&nbsp;-&gt;&nbsp;Int<br>
Ackerman&nbsp;0&nbsp;j&nbsp;=&nbsp;j+1<br>
Ackerman&nbsp;i&nbsp;0&nbsp;=&nbsp;Ackerman&nbsp;(i-1)&nbsp;1<br>
Ackerman&nbsp;i&nbsp;j&nbsp;=&nbsp;Ackerman&nbsp;(i-1)&nbsp;(Ackerman&nbsp;i&nbsp;(j-1))<br>
<br></div>
<div style="background-color:#FFFF45;">The computation of a lazy version of <span style="font-family:courier;">Ackerman 3 7</span> takes 14.8 seconds + 0.1 seconds for garbage collection on an old fashion MacII (5Mb heap). When both arguments are annotated as strict (which in this case will be done automatically by the compiler) the computation will only take 1.5 seconds + 0.0 seconds garbage collection. The gain is one order of magnitude. Instead of rewriting graphs the calculation is performed using stacks and registers where possible. The speed is comparable with a recursive call in highly optimised C or with the speed obtainable when the function was programmed directly in assembly.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"></div>
<p></p><h3 style="background-color:#9999FF;"><a id="_10.1.5">10.1.5 Changing Lazy into Strict Evaluation</a></h3>
<p style="text-align:justify;">So, lazy evaluation gives a notational freedom (no worrying about what is computed when) but it might cost space as well as time. In CLEAN the default lazy evaluation can therefore be turned into eager evaluation by adding strictness annotations to types.</p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">Strict</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>!</b></span></td></tr>
</table><p></p>
<p style="text-align:justify;">This can be done in several ways:</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">The CLEAN compiler has a built-in strictness analyzer based on <i>abstract reduction</i> Nöcker, 1993) (it can be optionally turned off). The analyzer searches for strict arguments of a function and annotate them internally as strict (<span style="color:blue;"><a href="#_10.1.1">see 10.1.1</a></span>). In this way lazy arguments are <i>automatically</i> turned into strict ones. This optimization does not influence the termination behavior of the program. It appears that the analyzer can find much information. The analysis itself is quite fast.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">The strictness analyzer cannot find all strict arguments. Therefore one can also <i>manually</i> annotate a function as being strict in a certain argument or in its result (<span style="color:blue;"><a href="#_10.1.1">see 10.1.1</a></span>).</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">By using strictness annotations, a programmer can define (partially) strict data structures Nöcker and Smetsers, 1993; <span style="color:blue;"><a href="#_10.1.3">see 10.1.3</a></span>). Whenever such a data structure occurs in a strict context (<span style="color:blue;"><a href="#_10.1.1">see 10.1.1</a></span>), its strict components will be evaluated.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;"> The order of evaluation of expressions in a function body can also be changed from lazy to strict by using a strict let-before expression <span style="color:blue;"><a href="CleanLanguageReport3.html#_3.5.4">see 3.5.4</a></span>).</td></tr></table>
<p style="text-align:justify;"><i>One has to be careful though. When a programmer manually changes lazy evaluation into strict evaluation, the termination behavior of the program might change. It is only safe to put strictness annotations in the case that the function or data constructor is known to be strict in the corresponding argument which means that the evaluation of that argument in advance does not change the termination behavior of the program. The compiler is not able to check this.</i></p>
<h2 style="background-color:#9999FF;"><a id="_10.2">10.2 Defining Graphs on the Global Level</a></h2>
<p style="text-align:justify;">Constant graphs can also be defined on a global level (for local constant graphs see <span style="color:blue;"><a href="CleanLanguageReport3.html#_3.6">3.6</a></span>).</p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">GraphDef</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">Selector <span style="font-family:courier;color:#993300;"><b>=</b></span>[<span style="font-family:courier;color:#993300;"><b>:</b></span>] GraphExpr <span style="font-family:courier;color:#0000FF;"><b>;</b></span></td></tr>
</table><p></p>
<p style="text-align:justify;">A <i>global graph definition</i> defines a global constant (closed) graph, i.e. a graph which has the same scope as a global function definition (<span style="color:blue;"><a href="CleanLanguageReport2.html#_2.1">see 2.1</a></span>). The selector variables that occur in the selectors of a global graph definition have a global scope just as globally defined functions.</p>
<p style="text-align:justify;">Special about <i>global</i> graphs (in contrast with <i>local</i> graphs) is that they are <i>not</i> garbage collected during the evaluation of the program  A global graph can be compared with a <i>CAF</i> (<i>Constant Applicative Form</i>): its value is computed at most once and remembered at run-time. A global graph can save execution-time at the cost of permanent space consumption.</p>
<p style="text-align:justify;">Syntactically the definition of a graph is distinguished from the definition of a function by the symbol which separates the left-hand side from the right-hand side: "<span style="font-family:courier;">=</span>" or "<span style="font-family:courier;">=&gt;</span>" is used for functions, while "<span style="font-family:courier;">=</span>" is used for local graphs and "<span style="font-family:courier;">=:</span>" for global graphs. However, in general "<span style="font-family:courier;">=</span>" is used both for functions and local graphs. Generally it is clear from the context which is meant (functions have parameters, selectors are also easy recognisible). However, when a simple constant is defined the syntax is ambiguous (it can be a constant function definition as well as a constant graph definition).</p>
<p style="text-align:justify;">To allow the use of the "<span style="font-family:courier;">=</span>" whenever possible, the following rule is followed. Locally constant definitions are <i>by default</i> taken to be <i>graph</i> definitions and therefore shared, globally they are <i>by default</i> taken to be <i>function</i> definitions (<span style="color:blue;"><a href="CleanLanguageReport3.html#_3.1">see 3.1</a></span>) and therefore recomputed. If one wants to obtain a different behavior one has to explicit state the nature of the constant definition (has it to be shared or has it to be recomputed) by using "<span style="font-family:courier;">=:</span>" (on the global level, meaning it is a constant graph which is shared) or "<span style="font-family:courier;">=&gt;</span>" (on the local level, meaning it is a constant function and has to be recomputed).</p>
<p></p><div style="background-color:#FFFF45;"> Global constant graph versus global constant function definition: <span style="font-family:courier;">biglist1</span> is a <i>graph</i> which is computed only once, <span style="font-family:courier;">biglist3</span> and <span style="font-family:courier;">biglist2</span> is a constant <i>function</i> which is computed every time it is applied.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
biglist1&nbsp;=&nbsp;&nbsp;&nbsp;[1..10000]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;a&nbsp;constant&nbsp;function&nbsp;(if&nbsp;defined&nbsp;globally)</span><br>
biglist2&nbsp;=:&nbsp;&nbsp;[1..10000]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;a&nbsp;graph&nbsp;(if&nbsp;defined&nbsp;globally)</span><br>
biglist3&nbsp;=&gt;&nbsp;&nbsp;[1..10000]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;a&nbsp;constant&nbsp;function</span><br></div>
<p></p><p style="text-align:justify;">A graph saves execution-time at the cost of space consumption. A constant function saves space at the cost of execution time. So, use graphs when the computation is time-consuming while the space consumption is small and constant functions in the other case.</p>
<h2 style="background-color:#9999FF;"><a id="_10.3">10.3 Defining Macros</a></h2>
<p style="text-align:justify;">Macros are functions (rewrite rules) which are applied at <i>compile-time</i> instead of at <i>run-time</i>. Macro's can be used to define constants, create in-line substitutions, rename functions, do conditional compilation etc. With a macro definition one can, for instance, assign a name to a constant such that it can be used as pattern on the left-hand side of a function definition.</p>
<p style="text-align:justify;">At compile-time the right-hand side of the <i>macro definition</i> will be substituted for every application of the macro in the scope of the macro definition. This saves a function call and makes basic blocks larger (see Plasmeijer and Van Eekelen, 1993) such that <i>better</i> code can be generated. A disadvantage is that also <i>more</i> code will be generated. Inline substitution is also one of the regular optimisations performed by the CLEAN compiler. To avoid code explosion a compiler will generally not substitute big functions. Macros give the programmer a possibility to control the substitution process manually to get an optimal trade-off between the efficiency of code and the size of the code.</p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">MacroDef</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">[MacroFixityDef]</td></tr>
<tr><td style="width:26.1111111111111%;padding:0 0 4px 0;" colspan="3"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">DefOfMacro</td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">MacroFixityDef</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>(</b></span><span style="font-family:courier;">FunctionName</span><span style="font-family:courier;color:#993300;"><b>)</b></span> [FixPrec] <span style="font-family:courier;color:#0000FF;"><b>;</b></span></td></tr>
<tr><td style="width:23.0290909090909%;padding:0 0 4px 0;">DefOfMacro</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:1.06181818181818%;padding:0 0 4px 0;">=</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">Function {<span style="font-family:courier;">Variable</span>} <span style="font-family:courier;color:#993300;"><b>:==</b></span> FunctionBody <span style="font-family:courier;color:#0000FF;"><b>;</b></span></td></tr>
<tr><td style="width:26.1111111111111%;padding:0 0 4px 0;" colspan="3"></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:71.8690909090909%;padding:0 0 4px 0;">[LocalFunctionAltDefs]</td></tr>
</table><p></p>
<p style="text-align:justify;">The compile-time substitution process is guaranteed to terminate. To ensure this some restrictions are imposed on Macro's (compared to common functions). Only variables are allowed as formal argument. A macro rule always consists of a single alternative. Furthermore,</p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;">8)</td><td style="text-align:justify;">Macro definitions are not allowed to be cyclic to ensure that the substitution process terminates.</td></tr></table>
<p></p><div style="background-color:#FFFF45;">Example of a macro definition.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
Black&nbsp;&nbsp;&nbsp;&nbsp;:==&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Macro&nbsp;definition</span><br>
White&nbsp;&nbsp;&nbsp;&nbsp;:==&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Macro&nbsp;definition</span><br>
<br>
::&nbsp;Color&nbsp;:==&nbsp;Int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Type&nbsp;synonym&nbsp;definition</span><br>
<br>
Invert::&nbsp;Color&nbsp;-&gt;&nbsp;Color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Function&nbsp;definition</span><br>
Invert&nbsp;Black&nbsp;=&nbsp;White<br>
Invert&nbsp;White&nbsp;=&nbsp;Black<br></div>
<p></p><p></p><div style="background-color:#FFFF45;">Example: macro to write (a?b) for lists instead of [a:b] and its use in the function map.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
(?)&nbsp;<span style="font-family:courier;color:#FF0000;"><b>infixr</b></span>&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Fixity&nbsp;of&nbsp;Macro</span><br>
(?)&nbsp;h&nbsp;t&nbsp;:==&nbsp;[h:t]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Macro&nbsp;definition&nbsp;of&nbsp;operator</span><br>
<br>
map::&nbsp;(a&nbsp;-&gt;&nbsp;b)&nbsp;[a]&nbsp;-&gt;&nbsp;[b]<br>
map&nbsp;f&nbsp;(x?xs)&nbsp;=&nbsp;f&nbsp;x&nbsp;?&nbsp;map&nbsp;f&nbsp;xs<br>
map&nbsp;f&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br></div>
<p></p><p style="text-align:justify;">Notice that macros can contain local function definitions. These local definitions (which can be recursive) will also be substituted inline. In this way complicated substitutions can be achieved resulting in efficient code.</p>
<p></p><div style="background-color:#FFFF45;">Example: macros can be used to speed up frequently used functions. See for instance the definition of the function <span style="font-family:courier;">foldl</span> in <span style="font-family:courier;">StdList</span>.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
foldl&nbsp;op&nbsp;r&nbsp;l&nbsp;:==&nbsp;foldl&nbsp;r&nbsp;l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;Macro&nbsp;definition</span><br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;&nbsp;&nbsp;foldl&nbsp;r&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;r<br>
&nbsp;&nbsp;&nbsp;&nbsp;foldl&nbsp;r&nbsp;[a:x]&nbsp;=&nbsp;foldl&nbsp;(op&nbsp;r&nbsp;a)&nbsp;x<br>
<br>
sum&nbsp;list&nbsp;=&nbsp;foldl&nbsp;(+)&nbsp;0&nbsp;list<br>
<br></div>
<div style="background-color:#FFFF45;">After substitution of the macro <span style="font-family:courier;">foldl</span> a very efficient function <span style="font-family:courier;">sum</span> will be generated by the compiler:</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
sum&nbsp;list&nbsp;=&nbsp;foldl&nbsp;0&nbsp;list<br>
where<br>
&nbsp;&nbsp;&nbsp;&nbsp;foldl&nbsp;r&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;r<br>
&nbsp;&nbsp;&nbsp;&nbsp;foldl&nbsp;r&nbsp;[a:x]&nbsp;=&nbsp;foldl&nbsp;((+)&nbsp;r&nbsp;a)&nbsp;x<br></div>
<p></p><p style="text-align:justify;">The expansion of the macros takes place before type checking. Type specifications of macro rules are not possible. When operators are defined as macros, fixity and associativity can be defined.</p>
<h2 style="background-color:#9999FF;"><a id="_10.4">10.4 Efficiency Tips</a></h2>
<p style="text-align:justify;">Here are some additional suggestions how to make your program more efficient:</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Use the CLEAN profiler to find out which frequently called functions are consuming a lot of space and/or time. If you modify your program, these functions are the ones to have a good look at.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Transform a recursive function to a tail-recursive function.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">It is better to accumulate results in parameters instead of in the right-hand side results.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">It is better to use records instead of tuples.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Arrays can be more efficient than lists since they allow constant access time on their elements and can be destructive updated.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">When functions return multiple ad-hoc results in a tuple put these results in a strict tuple instead (can be indicated in the type).</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Use strict data structures whenever possible.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Export the strictness information to other modules (the compiler will warn you if you don't).</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Make function strict in its arguments whenever possible.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Use macros for simple constant expressions or frequently used functions.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Use CAF's and local graphs to avoid recalculation of expressions.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Selections in a lazy context can better be transformed to functions which do a pattern match.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Higher order functions are nice but inefficient (the compiler will try to convert higher order function into first order functions).</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Constructors of high arity are inefficient.</td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">Increase the heap space in the case that the garbage collector takes place too often.</td></tr></table>
</body>
</html>
