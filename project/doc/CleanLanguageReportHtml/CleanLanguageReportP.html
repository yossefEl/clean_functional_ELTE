<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Clean Language Report</title>
</head>
<body style="font-family:Helvetica">
<div><div style="position: absolute;"><svg width="355.555555555556" height="177.777777777778">
<path d="M49.7777777777778 7.32929319639176 h280.888888888889 v141.785858051661 h-280.888888888889 Z M64 33.9959598630584 h252.444444444444 v88.4525247183276 h-252.444444444444 Z" stroke="none" fill="#3F87AF" fill-rule="evenodd"/>
<path d="M64 111.781817914719 h252.444444444444 v10.6666666666667 h-252.444444444444 Z" stroke="none" fill="#8C96A0"/>
<path d="M64 33.9959598630584 h252.444444444444 v10.6666666666667 h-252.444444444444 Z" stroke="none" fill="#8C96A0"/>
<path d="M64 44.6626265297251 h252.444444444444 v67.1191913849942 h-252.444444444444 Z" stroke="none" fill="#FFFFFF"/>
<path d="M99.1179703874409 137.550135143052 C93.2711853763986 133.302197180425,88.084448516421 128.213312506961,83.725936053644 122.448484581386 L110.089961763567 122.448484581386 Z" stroke="none" fill="#8C96A0"/>
<path d="M99.1179703874409 18.8943093013927 C93.2711853763986 23.1422472640192,88.084448516421 28.2311319374834,83.725936053644 33.9959598630584 L110.089961763567 33.9959598630584 Z" stroke="none" fill="#8C96A0"/>
<path d="M126.968649704419 100.555210486665 C109.380820468897 87.7769045717629,109.380820468897 61.5564287615705,126.968649704419 48.7781228466684 L116.780371998016 34.7551616108359 C89.6658019265873 54.45504989631,89.6658019265873 94.8782834370233,116.780371998016 114.578171722497 Z" stroke="none" fill="#8C96A0"/>
<path d="M113.645517319123 118.89292902583 C83.5996423751073 97.0633230878727,83.5996423751073 52.2700102454607,113.645517319123 30.4404043075029 L102.673525942996 15.3387537458372 C62.3680839449271 44.6223714674879,62.3680839449271 104.710961865845,102.673525942996 133.994579587496 Z" stroke="none" fill="#8C96A0"/>
<path d="M123.413094148863 104.110766042221 C105.825264913342 91.3324601273184,105.825264913342 65.111984317126,123.413094148863 52.3336784022239 L113.22481644246 38.3107171663915 C86.1102463710318 58.0106054518656,86.1102463710318 98.4338389925788,113.22481644246 118.133727278053  Z" stroke="none" fill="#3F87AF"/>
<path d="M110.089961763567 122.448484581386 C80.0440868195518 100.618878643428,80.0440868195518 55.8255658010162,110.089961763567 33.9959598630584L83.725936053644 33.9959598630584 C63.9432065006372 60.1617750913602,63.9432065006372 96.2826693530842,83.725936053644 122.448484581386" stroke="none" fill="#3F87AF"/>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="145.777777777778" y="103.111111111111" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="144.888888888889" y="102.222222222222" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="144" y="101.333333333333" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="143.111111111111" y="100.444444444444" fill="#8C96A0">Clean</text>
<text font-family="Helvetica" font-weight="bold" font-size="56.8888888888889px" x="142.222222222222" y="99.5555555555556" fill="#3F87AF">Clean</text>
</svg>
</div><div style="background-color:#9999FF;"><a id="_P"></a><h1 style="text-align:right;padding-top:0.6em;margin-bottom:0.6em;">Version 3.0<br>Language Report</h1>
<h1 style="text-align:right;margin-top:0.6em;">Preface</h1></div></div>
<p style="text-align:justify;">CLEAN is a practical applicable general-purpose lazy pure functional programming language suited for the development of real world applications.</p>
<p style="text-align:justify;">CLEAN has many features among which some very special ones.</p>
<p style="text-align:justify;">Functional languages are usually implemented using graph-rewriting techniques. CLEAN has explicit graph rewriting <i>semantics</i>; one can explicitly define the <i>sharing</i> of <i>structures</i> (<i>cyclic structures</i> as well) in the language (Barendregt et al., 1987; Sleep et al., 1993, Eekelen et al., 1997). This provides a better framework for controlling the time space behavior of functional programs.</p>
<p style="text-align:justify;">Of particular importance for practical use is CLEAN's Uniqueness Type System (Barendsen and Smetsers, 1993a) enabling the incorporation of destructive updates of arbitrary objects within a pure functional framework and the creation of direct interfaces with the outside world.</p>
<p style="text-align:justify;">CLEAN's "unique" features have made it possible to predefine (in CLEAN) a sophisticated and efficient I/O library (Achten and Plasmeijer, 1992 &amp; 1995). The CLEAN Object I/O library enables a CLEAN programmer to <i>specify interactive window based I/O applications</i> on a very high level of abstraction. One can define callback functions and I/O components with arbitrary local states thus providing an object-oriented style of programming (Achten, 1996; Achten and Plasmeijer, 1997). The library forms a platform independent interface to window-based systems: one can port window based I/O ap-plications written in CLEAN to different platforms (we support Mac and PC) without modification of source code.</p>
<p style="text-align:justify;">Although CLEAN is <i>by default</i> a <i>lazy language</i> one can smoothly turn it into a <i>strict language</i> to obtain optimal time/space behavior: <i>functions</i> can be defined <i>lazy</i> as well as <i>(partially) strict</i> in their arguments; any (recursive) <i>data structure</i> can be defined <i>lazy </i>as well as <i>(partially) strict</i> in any of its arguments.</p>
<p style="text-align:justify;">The rich type system of CLEAN 1.3 (offering high-order types, polymorph types, type classes, uniqueness types, existentially quantified types, algebraic types, abstract types, synonym types, record types, arrays, lists) is extended with <i>multi parameter type constructor classes</i> and <i>universally quantified types</i> currently limited to rank 2, rank n is in preparation). Furthermore, arrays and lists are better integrated in the language. Strict, spine-strict, unboxed and overloaded lists are predefined in the language.</p>
<p style="text-align:justify;">CLEAN now offers a hybrid type system with both static and dynamic typing. An object (expression) of static type can be changed into an object of dynamic type (a "<span style="font-family:courier;">Dynamic</span>") and backwards. One can read a <span style="font-family:courier;">Dynamic</span> written by another CLEAN program with one function call. A <span style="font-family:courier;">Dynamic</span> can contain data as well as (unevaluated) functions. This means that one can very easy transfer data as well as code (!) from one CLEAN application to another in a <i>type safe</i> manner enabling <i>mobile code</i> and <i>persistent storage</i> of an expression. This technique involves just-in-time code generation, dynamic linking and dynamic type unification.</p>
<p style="text-align:justify;">CLEAN offers support for generic programming using an extension of the class overloading mechanism. One can define functions like equality, <span style="font-family:courier;">map</span>, <span style="font-family:courier;">foldr</span> and the like in a generic way such that these functions are available for any (user defined) data structure. The generic functions are very flexible since they not only work on types of kind star but also on higher order kinds.</p>
<p style="text-align:justify;">CLEAN (Brus <i>et al.</i>, 1987; NÃ¶cker <i>et al.</i>, 1991; Plasmeijer and Van Eekelen, 1993) is not only well known for its many features but also for its fast compiler producing very efficient code (Smetsers <i>et al.</i>, 1991). The new CLEAN 2.0 compiler is written in CLEAN . The CLEAN compiler is one of the fastest in the world and it produces very good code. For example, the compiler can compile itself from scratch within a minute.</p>
<p style="text-align:justify;">The CLEAN 2.0 system includes lots of tools and libraries, all written in CLEAN of course. Included is an IDE (Integrated Development Environment), a dedicated text editor, a project manager, a code generator generating native code (the only piece of software written in C), a static linker, a dynamic linker, a proof system (Sparkle), a test system (GAST), a heap profiler, a time profiler, and lots of libraries.</p>
<p style="text-align:justify;">People already familiar with other functional programming languages (such as Haskell; (Hudak et al., 1992), Gofer/Hugs (Jones, 1993), Miranda (Turner, 1985) and SML (Harper et al., 1986)) will have no difficulty to program in CLEAN. We hope that you will enjoy CLEAN's rich collection of features, CLEAN's compilation speed and the quality of the produced code (we generate native code for all platforms we support). CLEAN runs on a PC (Windows 2000, '98, '95, WindowsNT). There are also versions running on the Mac and Linux.</p>
<p style="text-align:justify;">Research on CLEAN started in 1984 (the Dutch Parallel Machine Project) in which we had to good idea to focuss on compilation techniques for classical computer architectures. Many new concepts came out of the research of the CLEAN team (see below). These ideas are not only incorporated in our own system, many of them have also been adopted by other languages like Haskell and Mercury.</p>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More Information on Clean</h3>
<p style="text-align:justify;">A tutorial teaching how to program in CLEAN can be found on our web pages.</p>
<p style="text-align:justify;">See <a href="http://wiki.clean.cs.ru.nl/Functional_Programming_in_Clean" target="_blank">http://wiki.clean.cs.ru.nl/Functional_Programming_in_Clean</a>.</p>
<p style="text-align:justify;">Information about the libraries (including the I/O library) that are available for CLEAN can also be found on the web, surf to </p>
<p style="text-align:justify;"><a href="http://wiki.clean.cs.ru.nl/Libraries" target="_blank">http://wiki.clean.cs.ru.nl/Libraries</a>.</p>
<p style="text-align:justify;">There is a manual teaching the use of the Object I/O library. It includes many examples showing you how to write interactive window based programs.</p>
<p style="text-align:justify;">See <a href="http://clean.cs.ru.nl/download/supported/ObjectIO.1.2/doc/tutorial.pdf" target="_blank">http://clean.cs.ru.nl/download/supported/ObjectIO.1.2/doc/tutorial.pdf</a>.</p>
<p style="text-align:justify;">The basic concepts behind CLEAN (albeit of one of the very first versions, namely CLEAN 0.8) as well as an explanation of the basic implementation techniques used can be found in Plasmeijer and Van Eekelen (Adisson-Wesley, 1993). The book is out of print, but copies can found on </p>
<p style="text-align:justify;"><a href="http://wiki.clean.cs.ru.nl/Functional_Programming_and_Parallel_Graph_Rewriting" target="_blank">http://wiki.clean.cs.ru.nl/Functional_Programming_and_Parallel_Graph_Rewriting</a></p>
<p style="text-align:justify;">There are many papers on the concepts introduced by the CLEAN group (such as <i>term graph rewriting</i> (Barendregt <i>et al</i>., 1987), <i>lazy copying</i> (van Eekelen <i>et al</i>., 1991), <i>abstract reduction</i> (NÃ¶cker, 1993), <i>uniqueness typing</i> (Barendsen and Smetsers, 1993, 1996), CLEAN's <i>I/O concept</i> (Achten, 1996 &amp; 1997), <i>Lazy Copying</i> for Concurrent CLEAN (Kesseler, 1991 &amp; 1996), Type dependent Functions for Dynamics (Pil, 1999), I/O of Dynamics (Vervoort, 2001), a Typed Operating System (van Weelden, 2001). For the most recent information on papers (<a href="http://wiki.clean.cs.ru.nl/Publications" target="_blank">http://wiki.clean.cs.ru.nl/Publications</a>) and general information about CLEAN (<a href="http://clean.cs.ru.nl" target="_blank">http://clean.cs.ru.nl</a>) please check our web pages.</p>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;About this Language Report</h3>
<p style="text-align:justify;">In this report the syntax and semantics of CLEAN version 2.0 are explained. We always give a motivation <i>why</i> we have included a certain feature. Although the report is not intended as introduction into the language, we did our best to make it as readable as possible. Nevertheless, one sometimes has to work through several sections spread all over the report. We have included links where possible to support browsing through the manual.</p>
<p style="text-align:justify;">At several places in this report context free syntax fragments of CLEAN are given. We sometimes repeat fragments that are also given elsewhere just to make the description clearer (e.g. in the uniqueness typing chapter we repeat parts of the syntax for the classical types). We hope that this is not confusing. The complete collection of context free grammar rules is summarized in Appendix A.</p>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some Remarks on the Clean Syntax</h3>
<p style="text-align:justify;">The syntax of CLEAN is similar to the one used in most other modern functional languages. However, there are a couple of small syntactic differences we want to point out here for people who don?t like to read language reports.</p>
<p style="text-align:justify;">In CLEAN the arity of a function is reflected in its type. When a function is defined its uncurried type is specified! To avoid any confusion we want to explicitly state here that in CLEAN there is no restriction whatsoever on the curried use of functions. However, we don't feel a need to express this in every type. Actually, the way we express types of functions more clearly reflects the way curried functions are internally treated.</p>
<p></p><div style="background-color:#FFFF45;">E.g., the standard map function (arity 2) is specified in CLEAN as follows:</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
map::(a&nbsp;-&gt;&nbsp;b)&nbsp;[a]&nbsp;-&gt;&nbsp;[b]<br>
map&nbsp;f&nbsp;[]&nbsp;&nbsp;&nbsp;=&nbsp;[]<br>
map&nbsp;f&nbsp;[x:xs]&nbsp;&nbsp;=&nbsp;[f&nbsp;x:map&nbsp;f&nbsp;xs]<br></div>
<p></p><p style="text-align:justify;">Each predefined structure such as a list, a tuple, a record or array has its own kind of brackets: lazy lists are alwaysdenotated with square brackets <span style="font-family:courier;">[...]</span>, strict lists are denotated by <span style="font-family:courier;">[! ...]</span>, spine strict lists by <span style="font-family:courier;">[... !]</span>, overloaded lists by <span style="font-family:courier;"> [|...]]</span><span style="font-family:courier;"> , unboxed lists by </span><span style="font-family:courier;">[#...]</span>. For tuples the usual parentheses are used <span style="font-family:courier;">(...,...)</span>, curly braces are used for records (indexed by field name) as well as for arrays (indexed by number).</p>
<p style="text-align:justify;">In types funny symbols can appear like <span style="font-family:courier;">.</span>, <span style="font-family:courier;">u:</span>, <span style="font-family:courier;">*,</span> <span style="font-family:courier;">!</span> which can be ignored and left out if one is not interested in uniqueness typing or strictness.</p>
<p style="text-align:justify;">There are only a few keywords in CLEAN leading to a heavily overloaded use of <span style="font-family:courier;">:</span> and <span style="font-family:courier;">=</span> symbols:</p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">function::argstype&nbsp;-&gt;&nbsp;restype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;type&nbsp;specification&nbsp;of&nbsp;a&nbsp;function</span><br><p></p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">function&nbsp;pattern<br>
|&nbsp;guard&nbsp;=&nbsp;rhs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;definition&nbsp;of&nbsp;a&nbsp;function</span><br><p></p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">selector&nbsp;=&nbsp;graph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;definition&nbsp;of&nbsp;a&nbsp;constant/CAF/graph</span><br><p></p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">function&nbsp;args&nbsp;:==&nbsp;rhs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;definition&nbsp;of&nbsp;a&nbsp;macro</span><br><p></p>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">::Type&nbsp;args&nbsp;=&nbsp;typedef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;an&nbsp;algebraic&nbsp;data&nbsp;type&nbsp;definition</span><br>
::Type&nbsp;args&nbsp;:==&nbsp;typedef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;a&nbsp;type&nbsp;synonym&nbsp;definition</span><br>
::Type&nbsp;args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000FF;">//&nbsp;an&nbsp;abstract&nbsp;type&nbsp;definition</span><br><p></p>
<p style="text-align:justify;">As is common in modern functional languages, there is a layout rule in CLEAN (<span style="color:blue;"><a href="CleanLanguageReport2.html#_2.3">see 2.3</a></span>). For reasons of portability it is assumed that a tab space is set to 4 white spaces and that a non-proportional font is used.</p>
<p></p><div style="background-color:#FFFF45;">Function definition in CLEAN making use of the layout rule.</div>
<div style="font-family:courier;margin:0px;background-color:#FFFF99;"><br>
primes::&nbsp;[Int]<br>
primes&nbsp;=&nbsp;sieve&nbsp;[2..]<br>
<span style="font-family:courier;color:#FF0000;"><b>where</b></span><br>
&nbsp;&nbsp;sieve::&nbsp;[Int]&nbsp;-&gt;&nbsp;[Int]<br>
&nbsp;&nbsp;sieve&nbsp;[pr:r]&nbsp;&nbsp;=&nbsp;[pr:sieve&nbsp;(filter&nbsp;pr&nbsp;r)]<br>
<br>
&nbsp;&nbsp;filter::&nbsp;Int&nbsp;[Int]&nbsp;-&gt;&nbsp;[Int]<br>
&nbsp;&nbsp;filter&nbsp;pr&nbsp;[n:r]<br>
&nbsp;&nbsp;|&nbsp;n&nbsp;mod&nbsp;pr&nbsp;==&nbsp;0&nbsp;&nbsp;=&nbsp;filter&nbsp;pr&nbsp;r<br>
&nbsp;&nbsp;|&nbsp;<span style="font-family:courier;color:#FF0000;"><b>otherwise</b></span>&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[n:filter&nbsp;pr&nbsp;r]<br></div>
<p></p><h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notational Conventions Used in this Report</h3>
<p style="text-align:justify;">The following <i>notational conventions</i> are used in this report. Text is printed in Microsoft Sans Serif 9pts,</p>
<table style="background-color:#FFCC99;width:100%;" cellspacing="0" cellpadding="0"><tr><td style="width:100%;padding:0 0 4px 0;">the context free syntax descriptions are given in  Microsoft Sans Serif 9pts,</td></tr>
</table><p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">examples&nbsp;of&nbsp;CLEAN&nbsp;programs&nbsp;are&nbsp;given&nbsp;in&nbsp;Courier&nbsp;New&nbsp;9pts,<br><p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Semantic restrictions are always given in a bulleted list-of-points. When these restrictions are not obeyed they will almost always result in a compile-time error. In very few cases the restrictions can only be detected at run-time (array index out-of-range, partial function called outside the domain).</td></tr>
</table>
<p style="text-align:justify;">The following notational conventions are used in the context-free syntax descriptions:</p>
<p></p><table style="width:100%;"><tr><td style="width:9.81818181818182%;padding:0 0 4px 0;">[notion]</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">means that the presence of notion is optional</td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;">{notion}</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">means that notion can occur zero or more times</td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;">{notion}+</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">means that notion occurs at least once</td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;">{notion}-<i>list</i></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">means one or more occurrences of notion separated by commas</td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;"><span style="font-family:courier;color:#993300;"><b>terminals</b></span></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">are printed in <span style="font-family:courier;color:#993300;"><b>9 pts courier bold brown</b></span></td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;"><span style="font-family:courier;color:#FF0000;"><b>keywords</b></span></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">are printed in <span style="font-family:courier;color:#FF0000;"><b>9 pts courier bold red</b></span></td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;"><span style="font-family:courier;color:#0000FF;"><b>terminals</b></span></td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">that can be left out in layout mode are printed in <span style="font-family:courier;color:#0000FF;"><b>9 pts courier bold blue</b></span></td></tr>
<tr><td style="width:9.81818181818182%;padding:0 0 4px 0;">{notion}/ str</td><td style="width:2.02020202020202%;padding:0 0 4px 0;"></td><td style="width:64.0018181818182%;padding:0 0 4px 0;">means the longest expression not containing the string str</td></tr>
</table><p></p>
<p style="text-align:justify;">All CLEAN examples given in this report assume that the layout dependent mode has been chosen which means that redundant semi-colons and curly braces are left out (<span style="color:blue;"><a href="CleanLanguageReport2.html#_2.3.3">see 2.3.3</a></span>).</p>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How to Obtain Clean</h3>
<p style="text-align:justify;">CLEAN and the INTEGRATED DEVELOPMENT ENVIRONMENT (IDE) can be used free of charge. They can be obtained</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">via World Wide Web (<a href="http://clean.cs.ru.nl" target="_blank">http://clean.cs.ru.nl</a>) or </td></tr><tr><td style="vertical-align:top;width:30px;">&bull;</td><td style="text-align:justify;">via ftp (<a href="ftp://ftp.cs.ru.nl" target="_blank">ftp://ftp.cs.ru.nl</a> in directory <i>pub/Clean)</i></td></tr></table>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current State of the Clean System</h3>
<p style="text-align:justify;"><span style="font-family:courier;color:#993300;"><b>Release 2.1 (November 2002).</b></span></p>
<p style="text-align:justify;">Compared with the previous version the following changes have been made.</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Experimental features of the previous version, such as dynamics (<span style="color:blue;"><a href="CleanLanguageReport8.html#_8">see Chapter 8</a></span>), generics (<span style="color:blue;"><a href="CleanLanguageReport7.html#_7">see Chapter 7</a></span>) and strict-lists (<span style="color:blue;"><a href="CleanLanguageReport4.html#_4.2">see 4.2</a></span>) have been improved and further incorporated in the language.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Many bugs, most of which appeared in the new features, have been removed.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The quality of the generated code has been improved.</td></tr>
</table>
<p style="text-align:justify;"><span style="font-family:courier;color:#993300;"><b>Release 2.0 (November 2001).</b></span></p>
<p style="text-align:justify;">There are <i>many</i> changes compared to the previous release (CLEAN 1.3.x). We have added many new features in CLEAN 2.0 we hope you will like.</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">CLEAN 2.0 has multi-parameter type constructor classes. <span style="color:blue;"><a href="CleanLanguageReport6.html#_6.4">See Section 6.4</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">CLEAN 2.0 has universally quantified data types and functions (rank 2). See Section <span style="color:blue;"><a href="CleanLanguageReport3.html#_3.7.4">3.7.4</a></span> and <span style="color:blue;"><a href="CleanLanguageReport5.html#_5.1.4">5.1.4</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The explicit import mechanism has been refined. One can now more precisely address what to import and what not. <span style="color:blue;"><a href="CleanLanguageReport2.html#_2.5.1">See 2.5.1</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Cyclic depedencies between definition modules are allowed. This makes it easier to define implementation modules that share definitions. <span style="color:blue;"><a href="CleanLanguageReport2.html#_2.5.1">See 2.5.1</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Definitions in a definition module need not to be repeated in the corresponding implementation module anymore. <span style="color:blue;"><a href="CleanLanguageReport2.html#_2.4">See 2.4</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Due to multi-parameter type constructor classes a better incorporation of the type Array could be made. <span style="color:blue;"><a href="CleanLanguageReport4.html#_4.4">See 4.4</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">CLEAN 2.0 offers an hybrid type system: one can have statically and dynamically typed objects (<b>Dynamics</b>). A statically typed expression can be changed into a dynamically typed one and backwards. The type of a <span style="font-family:courier;">Dynamic</span>can be inspected via a pattern match, one can ensure that <span style="font-family:courier;">Dynamics</span> fit together by using run-time type unification, one can store a <span style="font-family:courier;">Dynamic</span> into a file with one function call or read a <span style="font-family:courier;">Dynamic</span> stored by another CLEAN application. <span style="font-family:courier;">Dynamics</span> can be used to store and retrieve information without the need for writing parsers, it can be used to exchange data and code (!) between applications in a type safe manner. <span style="font-family:courier;">Dynamics</span>make it easy to create mobile code, create plug-ins or create a persistent store. The CLEAN run-time system has been extended to support dynamic type checking, dynamic type unification, lazy dynamic linking and just-in-time code generation (<span style="color:blue;"><a href="CleanLanguageReport8.html#_8">See Chapter 8</a></span>).</td></tr>
</table>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">There is special syntax and support for strict and unboxed lists. One can easily change from lazy to strict and backwards. Overloaded functions can be defined which work for any list (lazy, strict or unboxed). <span style="color:blue;"><a href="CleanLanguageReport4.html#_4.2">See 4.2</a></span>. One can write functions like <span style="font-family:courier;">==</span>, <span style="font-family:courier;">map</span>, <span style="font-family:courier;">foldr</span> in a generic way. The <span style="font-family:courier;">generic functions</span> one can define can work on higher order kinds. With kind indexed functions one can indicated which kind is actually meant (<span style="color:blue;"><a href="CleanLanguageReport7.html#_7">see Chapter 7</a></span>). A generic definition can be specialized for a certain concrete type.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The CLEAN system has been changed and extended: a new version of the CLEAN IDE, a new version of the run-time-system, and a dynamic linker is included. <span style="color:blue;"><a href="CleanLanguageReport8.html#_8.3">See 8.3</a></span>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">CLEAN 2.0 comes with an integrated proof system  (Sparkle), all written in CLEAN of course. See <a href="http://www.cs.kun.nl/Sparkle" target="_blank">http://www.cs.kun.nl/Sparkle</a>.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">CLEAN 2.0 is open source. All source code will be made available on the net.</td></tr>
</table>
<p style="text-align:justify;">We have also removed things:</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">We do not longer support annotations for concurrent evaluations ({P} and {I} annotations. However, we are working on a library that will support distributed evaluation of CLEAN expressions using Dynamics (see Van Weelden and Plasmeijer, 2002).</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">There is no strict let-before expression (<span style="font-family:courier;">let!</span>) anymore in CLEAN 2.x. You still can enforce strict evaluation using the strict hash let (<span style="font-family:courier;">#!</span>).</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">One cannot specify default instances anymore that could be used to disambiguate possible ambiguous internal overloading. Disambiguating can be done by explicitely specifying the required type.</td></tr>
</table>
<p style="text-align:justify;">There is also some bad news:</p>
<table style="border-spacing:0;width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">Due to all these changes CLEAN 2.0 is <i>not</i> upwards compatible with CLEAN 1.3.x. Many things are the same but there are small differences as well. So, one has to put some effort in porting a CLEAN 1.3.x application to CLEAN 2.0. The most important syntactical differences are described below. Note that we do no longer support CLEAN 1.3.</td></tr>
<tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The CLEAN 1.3 compiler is written in C. The CLEAN 2.0 compiler has been rewritten from scratch in CLEAN. The internal structure of the new compiler is a better than the old one, but the new compiler has become a bit slower than the previous C version as well. Large programs will take about 1.7 times as much time to compile (which is still pretty impressive for a lazy functional language).</td></tr>
</table>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Syntactic differences between Clean 1.3 and Clean 2.0</h3>
<p style="text-align:justify;">CLEAN 2.x is not downward compatible with CLEAN 1.3.x. Probably you have to change your 1.3.x sources to get them through the CLEAN 2.x compiler.</p>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differences in Expression Syntax</h3>
<p style="text-align:justify;">There is no <i>strict let</i> expression (<span style="font-family:courier;">let!</span>) anymore in CLEAN 2.x. You still can enforce strict evaluation using the strict hash let (<span style="font-family:courier;">#!</span>).</p>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differences in the Type System</h3>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">For <i>multiparameter type</i> classes a small change in the syntax for instance definitions was necessary. In CLEAN 1.3.x it was assumed that every instance definition only has one type argument. So in the following 1.3.x instance definition</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;c&nbsp;T1&nbsp;T2<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">the type <span style="font-family:courier;">(T1 T2)</span> was meant (the type <span style="font-family:courier;">T1</span> with the argument <span style="font-family:courier;">T2</span>). This should be written in CLEAN 2.x as</td></tr></table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;c&nbsp;(T1&nbsp;T2)<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">otherwise <span style="font-family:courier;">T1</span> and <span style="font-family:courier;">T2</span> will be interpreted as two types.</td></tr></table>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The <i>type</i> <span style="font-family:courier;">Array</span> has changed. In CLEAN 2.x the <span style="font-family:courier;">Array</span> class has become a multiparameter class, whose first argument type is the array and whose second argument type is the array element (see ??). Therefore a 1.3 definition like</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MkArray::&nbsp;!Int&nbsp;(Int&nbsp;-&gt;&nbsp;e)&nbsp;-&gt;.(a&nbsp;e)&nbsp;|&nbsp;Array&nbsp;a&nbsp;&amp;&nbsp;ArrayElem&nbsp;e<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MkArray&nbsp;i&nbsp;f&nbsp;=&nbsp;{f&nbsp;j&nbsp;\&nbsp;j&nbsp;&lt;-&nbsp;[0..i-1]}<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">becomes in CLEAN 2.x:</td></tr></table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MkArray::&nbsp;!Int&nbsp;(Int&nbsp;-&gt;&nbsp;e)&nbsp;-&gt;.(a&nbsp;e)&nbsp;|&nbsp;Array&nbsp;a&nbsp;e<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MkArray&nbsp;i&nbsp;f&nbsp;=&nbsp;{f&nbsp;j&nbsp;\&nbsp;j&nbsp;&lt;-&nbsp;[0..i-1]}<br><p></p>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">There is a difference in <i>resolving overloading</i>. Consider the following code:</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;c&nbsp;a&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;a<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;c&nbsp;[Int]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;[1]&nbsp;=&nbsp;[2]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;[x:xs]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;c&nbsp;xs<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">Although this is accepted by CLEAN 1.3.x, CLEAN 2.x will complain: "Overloading error [...,..,f]: c no instance available of type [a]." The CLEAN 2.x compiler applies no type unification after resolving overloading. So <span style="font-family:courier;">c</span> is in function <span style="font-family:courier;">f</span> applied to a list with a polymorph element type (<span style="font-family:courier;">[a]</span>). And this is considered to be different from the instance type <span style="font-family:courier;">[Int]</span>. If you give f the type <span style="font-family:courier;">[Int] -&gt; [Int]</span> the upper code will be accepted.</td></tr></table>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">CLEAN 2.x handles <i>uniqueness attributes in type synonyms</i> different than CLEAN 1.3.x. Consider the following definitions:</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;ListList&nbsp;a&nbsp;:==&nbsp;[[a]]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;::&nbsp;*(ListList&nbsp;*{Int})&nbsp;-&gt;&nbsp;*{Int}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;[[a]]&nbsp;=&nbsp;{&nbsp;a&nbsp;&amp;&nbsp;[0]=0&nbsp;}<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">In CLEAN 1.3.x the <span style="font-family:courier;">ListList</span> type synonym was expanded to</td></tr></table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;::&nbsp;*[*[*{Int}]]&nbsp;-&gt;&nbsp;*{Int}<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">which is correct in CLEAN 1.3.x. However, CLEAN 2.x expands it to</td></tr></table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;::&nbsp;*[[*{Int}]]&nbsp;-&gt;&nbsp;*{Int}<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">This yields a uniqueness error in CLEAN 2.x because the inner list is shared but contains a unique object. This problem happens only with type synonyms that have attributes "inbetween". An "inbetween" attribute is neither the "root" attribute nor the attribute of an actual argument. E.g. with the upper type synonym, the formal argument "<span style="font-family:courier;">a</span>" is substituted with <span style="font-family:courier;">*{Int}</span>. Note that also the "<span style="font-family:courier;">*</span>" is substituted for "<span style="font-family:courier;">a</span>". Because we wrote <span style="font-family:courier;">*(ListList ...)</span> the root attribute is "<span style="font-family:courier;">*</span>". The result of expanding <span style="font-family:courier;">*(ListList *{Int})</span> is <span style="font-family:courier;">*[u:[*{Int]]</span>. "<span style="font-family:courier;">u</span>" is an attribute "inbetween" because it is neither the root attribute nor the attribute of a formal argument. Such attributes are made _non_unique_ in CLEAN 2.x and this is why the upper code is not accepted. The code will be accepted if you redefine <span style="font-family:courier;">ListList</span> to</td></tr></table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;ListList&nbsp;a&nbsp;:==&nbsp;[*[a]]<br><p></p>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;"><i>Anonymous uniqueness attributes in type contexts</i> are not allowed in CLEAN 2.x. So in the following function type simply remove the point.</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;::&nbsp;a&nbsp;|&nbsp;myClass&nbsp;.a<br><p></p>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The <span style="font-family:courier;">String</span> type has become a <i>predefined type</i>. As a consequence you cannot import this type explicitly anymore. So:</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;StdString&nbsp;import&nbsp;::&nbsp;String<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">is not valid.</td></tr></table>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">There was a bug in the uniqueness typing system of CLEAN 1.3: Records or data constructors could have existentially quantified variables, whose uniqueness attribute did _not_ propagate. This bug has been solved in CLEAN 2.x. As a consequence, the 2.x compiler might complain about your program where the 1.3.x compiler was happy. The problem might occur when you use the object I/O library and you use objects with a uniquely attributed local state. Now the object becomes unique as well and may not be shared anymore.</td></tr>
</table>
<h3 style="background-color:#9999FF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differences in the Module System</h3>
<p></p><table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"><table style="border-top:7px solid white;border-bottom:1px solid white;border-left:0px solid white;border-right:8px solid white;width:16px;height:16px;background:#FFCC99;float:left"></table>
</td><td style="text-align:justify;">The syntax and semantics of <i>explicit import statements</i> has been completely revised. With CLEAN 2.x it is possible to discriminate the different namespaces in import statements. In CLEAN 1.3.x the following statement</td></tr>
</table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:courier;color:#FF0000;"><b>from</b></span>&nbsp;m&nbsp;<span style="font-family:courier;color:#FF0000;"><b>import</b></span>&nbsp;F<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">could have caused the import of a <i>function</i> <span style="font-family:courier;">F</span> together with a <i>type</i> <span style="font-family:courier;">F</span> and a <i>class</i> <span style="font-family:courier;">F</span> with all its instances from m. In CLEAN 2.x one can precisely describe from which name space one wants to import (<span style="color:blue;"><a href="CleanLanguageReport2.html#_2.5.2">see 2.5.2</a></span>). For example, the following import statement</td></tr></table>
<p></p>
<p style="font-family:courier;margin:0px;background-color:#FFFF99;line-height:1.125;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:courier;color:#FF0000;"><b>from</b></span>&nbsp;m&nbsp;<span style="font-family:courier;color:#FF0000;"><b>import</b></span>&nbsp;&nbsp;F,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;T1,&nbsp;::&nbsp;T2(..),&nbsp;::&nbsp;T3(C1,&nbsp;C2),&nbsp;::&nbsp;T4{..},&nbsp;::&nbsp;T5{field1,&nbsp;field2},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;C1,&nbsp;<span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;C2(..),&nbsp;<span style="font-family:courier;color:#FF0000;"><b>class</b></span>&nbsp;C3(mem1,&nbsp;mem2)<br><p></p>
<table style="width:100%;"><tr><td style="vertical-align:top;width:30px;"></td><td style="text-align:justify;">causes the following declarations to be imported: the <i>function</i> or <i>macro</i> <span style="font-family:courier;">F</span>, the <i>type</i> <span style="font-family:courier;">T1</span>, the <i>algebraic type</i> <span style="font-family:courier;">T2</span> with <i>all</i> it's constructors that are exported by <span style="font-family:courier;">m</span>, the <i>algebraic type</i> <span style="font-family:courier;">T3</span> with it's constructors <span style="font-family:courier;">C1</span> and <span style="font-family:courier;">C2</span>, the <i>record type</i> <span style="font-family:courier;">T4</span> with <i>all</i> it's fields that are exported by <span style="font-family:courier;">m</span>, the <i>record type</i> <span style="font-family:courier;">T5</span> with it's fields <span style="font-family:courier;">field1</span> and <span style="font-family:courier;">field2</span>, the <i>class</i> <span style="font-family:courier;">C1</span>, the<i>class</i> <span style="font-family:courier;">C2</span> with all it's members that are exported by <span style="font-family:courier;">m</span>, the <i>class</i> <span style="font-family:courier;">C3</span> with it's members <span style="font-family:courier;">mem1</span> and <span style="font-family:courier;">mem2</span>.</td></tr></table>
<p style="text-align:justify;"><span style="font-family:courier;color:#993300;"><b>Previous Releases.</b></span>The first release of CLEAN was publicly available in 1987 and had version number 0.5 (we thought half of the work was done, ;-)). At that time, CLEAN was only thought as an intermediate language. Many releases followed. One of them was version 0.8 which is used in the Plasmeijer &amp; Van Eekelen Bible (Adisson-Wesley, 1993). Version 1.0 was the first mature version of CLEAN.</p>
</body>
</html>
